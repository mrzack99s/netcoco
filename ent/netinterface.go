// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/mrzack99s/netcoco/ent/device"
	"github.com/mrzack99s/netcoco/ent/netinterface"
	"github.com/mrzack99s/netcoco/ent/netinterfacemode"
	"github.com/mrzack99s/netcoco/ent/portchannelinterface"
	"github.com/mrzack99s/netcoco/ent/vlan"
)

// NetInterface is the model entity for the NetInterface schema.
type NetInterface struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// InterfaceName holds the value of the "interface_name" field.
	InterfaceName string `json:"interface_name,omitempty"`
	// InterfaceShutdown holds the value of the "interface_shutdown" field.
	InterfaceShutdown bool `json:"interface_shutdown,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the NetInterfaceQuery when eager-loading is set.
	Edges                             NetInterfaceEdges `json:"edges"`
	device_interfaces                 *int
	net_interface_mode_modes          *int
	port_channel_interface_interfaces *int
	vlan_native_vlan                  *int
}

// NetInterfaceEdges holds the relations/edges for other nodes in the graph.
type NetInterfaceEdges struct {
	// OnDevice holds the value of the on_device edge.
	OnDevice *Device `json:"on_device,omitempty"`
	// OnPoInterface holds the value of the on_po_interface edge.
	OnPoInterface *PortChannelInterface `json:"on_po_interface,omitempty"`
	// Mode holds the value of the mode edge.
	Mode *NetInterfaceMode `json:"mode,omitempty"`
	// HaveVlans holds the value of the have_vlans edge.
	HaveVlans []*Vlan `json:"have_vlans,omitempty"`
	// NativeOnVlan holds the value of the native_on_vlan edge.
	NativeOnVlan *Vlan `json:"native_on_vlan,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// OnDeviceOrErr returns the OnDevice value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NetInterfaceEdges) OnDeviceOrErr() (*Device, error) {
	if e.loadedTypes[0] {
		if e.OnDevice == nil {
			// The edge on_device was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: device.Label}
		}
		return e.OnDevice, nil
	}
	return nil, &NotLoadedError{edge: "on_device"}
}

// OnPoInterfaceOrErr returns the OnPoInterface value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NetInterfaceEdges) OnPoInterfaceOrErr() (*PortChannelInterface, error) {
	if e.loadedTypes[1] {
		if e.OnPoInterface == nil {
			// The edge on_po_interface was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: portchannelinterface.Label}
		}
		return e.OnPoInterface, nil
	}
	return nil, &NotLoadedError{edge: "on_po_interface"}
}

// ModeOrErr returns the Mode value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NetInterfaceEdges) ModeOrErr() (*NetInterfaceMode, error) {
	if e.loadedTypes[2] {
		if e.Mode == nil {
			// The edge mode was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: netinterfacemode.Label}
		}
		return e.Mode, nil
	}
	return nil, &NotLoadedError{edge: "mode"}
}

// HaveVlansOrErr returns the HaveVlans value or an error if the edge
// was not loaded in eager-loading.
func (e NetInterfaceEdges) HaveVlansOrErr() ([]*Vlan, error) {
	if e.loadedTypes[3] {
		return e.HaveVlans, nil
	}
	return nil, &NotLoadedError{edge: "have_vlans"}
}

// NativeOnVlanOrErr returns the NativeOnVlan value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e NetInterfaceEdges) NativeOnVlanOrErr() (*Vlan, error) {
	if e.loadedTypes[4] {
		if e.NativeOnVlan == nil {
			// The edge native_on_vlan was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: vlan.Label}
		}
		return e.NativeOnVlan, nil
	}
	return nil, &NotLoadedError{edge: "native_on_vlan"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*NetInterface) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case netinterface.FieldInterfaceShutdown:
			values[i] = new(sql.NullBool)
		case netinterface.FieldID:
			values[i] = new(sql.NullInt64)
		case netinterface.FieldInterfaceName:
			values[i] = new(sql.NullString)
		case netinterface.ForeignKeys[0]: // device_interfaces
			values[i] = new(sql.NullInt64)
		case netinterface.ForeignKeys[1]: // net_interface_mode_modes
			values[i] = new(sql.NullInt64)
		case netinterface.ForeignKeys[2]: // port_channel_interface_interfaces
			values[i] = new(sql.NullInt64)
		case netinterface.ForeignKeys[3]: // vlan_native_vlan
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type NetInterface", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the NetInterface fields.
func (ni *NetInterface) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case netinterface.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ni.ID = int(value.Int64)
		case netinterface.FieldInterfaceName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field interface_name", values[i])
			} else if value.Valid {
				ni.InterfaceName = value.String
			}
		case netinterface.FieldInterfaceShutdown:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field interface_shutdown", values[i])
			} else if value.Valid {
				ni.InterfaceShutdown = value.Bool
			}
		case netinterface.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field device_interfaces", value)
			} else if value.Valid {
				ni.device_interfaces = new(int)
				*ni.device_interfaces = int(value.Int64)
			}
		case netinterface.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field net_interface_mode_modes", value)
			} else if value.Valid {
				ni.net_interface_mode_modes = new(int)
				*ni.net_interface_mode_modes = int(value.Int64)
			}
		case netinterface.ForeignKeys[2]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field port_channel_interface_interfaces", value)
			} else if value.Valid {
				ni.port_channel_interface_interfaces = new(int)
				*ni.port_channel_interface_interfaces = int(value.Int64)
			}
		case netinterface.ForeignKeys[3]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field vlan_native_vlan", value)
			} else if value.Valid {
				ni.vlan_native_vlan = new(int)
				*ni.vlan_native_vlan = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryOnDevice queries the "on_device" edge of the NetInterface entity.
func (ni *NetInterface) QueryOnDevice() *DeviceQuery {
	return (&NetInterfaceClient{config: ni.config}).QueryOnDevice(ni)
}

// QueryOnPoInterface queries the "on_po_interface" edge of the NetInterface entity.
func (ni *NetInterface) QueryOnPoInterface() *PortChannelInterfaceQuery {
	return (&NetInterfaceClient{config: ni.config}).QueryOnPoInterface(ni)
}

// QueryMode queries the "mode" edge of the NetInterface entity.
func (ni *NetInterface) QueryMode() *NetInterfaceModeQuery {
	return (&NetInterfaceClient{config: ni.config}).QueryMode(ni)
}

// QueryHaveVlans queries the "have_vlans" edge of the NetInterface entity.
func (ni *NetInterface) QueryHaveVlans() *VlanQuery {
	return (&NetInterfaceClient{config: ni.config}).QueryHaveVlans(ni)
}

// QueryNativeOnVlan queries the "native_on_vlan" edge of the NetInterface entity.
func (ni *NetInterface) QueryNativeOnVlan() *VlanQuery {
	return (&NetInterfaceClient{config: ni.config}).QueryNativeOnVlan(ni)
}

// Update returns a builder for updating this NetInterface.
// Note that you need to call NetInterface.Unwrap() before calling this method if this NetInterface
// was returned from a transaction, and the transaction was committed or rolled back.
func (ni *NetInterface) Update() *NetInterfaceUpdateOne {
	return (&NetInterfaceClient{config: ni.config}).UpdateOne(ni)
}

// Unwrap unwraps the NetInterface entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ni *NetInterface) Unwrap() *NetInterface {
	tx, ok := ni.config.driver.(*txDriver)
	if !ok {
		panic("ent: NetInterface is not a transactional entity")
	}
	ni.config.driver = tx.drv
	return ni
}

// String implements the fmt.Stringer.
func (ni *NetInterface) String() string {
	var builder strings.Builder
	builder.WriteString("NetInterface(")
	builder.WriteString(fmt.Sprintf("id=%v", ni.ID))
	builder.WriteString(", interface_name=")
	builder.WriteString(ni.InterfaceName)
	builder.WriteString(", interface_shutdown=")
	builder.WriteString(fmt.Sprintf("%v", ni.InterfaceShutdown))
	builder.WriteByte(')')
	return builder.String()
}

// NetInterfaces is a parsable slice of NetInterface.
type NetInterfaces []*NetInterface

func (ni NetInterfaces) config(cfg config) {
	for _i := range ni {
		ni[_i].config = cfg
	}
}

// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/mrzack99s/netcoco/ent/administrator"
	"github.com/mrzack99s/netcoco/ent/deletedvlanlog"
	"github.com/mrzack99s/netcoco/ent/device"
	"github.com/mrzack99s/netcoco/ent/deviceplatform"
	"github.com/mrzack99s/netcoco/ent/devicetype"
	"github.com/mrzack99s/netcoco/ent/netinterface"
	"github.com/mrzack99s/netcoco/ent/netinterfacemode"
	"github.com/mrzack99s/netcoco/ent/nettopology"
	"github.com/mrzack99s/netcoco/ent/nettopologydevicemap"
	"github.com/mrzack99s/netcoco/ent/portchannelinterface"
	"github.com/mrzack99s/netcoco/ent/predicate"
	"github.com/mrzack99s/netcoco/ent/vlan"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdministrator        = "Administrator"
	TypeDeletedVlanLog       = "DeletedVlanLog"
	TypeDevice               = "Device"
	TypeDevicePlatform       = "DevicePlatform"
	TypeDeviceType           = "DeviceType"
	TypeNetInterface         = "NetInterface"
	TypeNetInterfaceMode     = "NetInterfaceMode"
	TypeNetTopology          = "NetTopology"
	TypeNetTopologyDeviceMap = "NetTopologyDeviceMap"
	TypePortChannelInterface = "PortChannelInterface"
	TypeVlan                 = "Vlan"
)

// AdministratorMutation represents an operation that mutates the Administrator nodes in the graph.
type AdministratorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	password      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Administrator, error)
	predicates    []predicate.Administrator
}

var _ ent.Mutation = (*AdministratorMutation)(nil)

// administratorOption allows management of the mutation configuration using functional options.
type administratorOption func(*AdministratorMutation)

// newAdministratorMutation creates new mutation for the Administrator entity.
func newAdministratorMutation(c config, op Op, opts ...administratorOption) *AdministratorMutation {
	m := &AdministratorMutation{
		config:        c,
		op:            op,
		typ:           TypeAdministrator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdministratorID sets the ID field of the mutation.
func withAdministratorID(id int) administratorOption {
	return func(m *AdministratorMutation) {
		var (
			err   error
			once  sync.Once
			value *Administrator
		)
		m.oldValue = func(ctx context.Context) (*Administrator, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Administrator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdministrator sets the old Administrator of the mutation.
func withAdministrator(node *Administrator) administratorOption {
	return func(m *AdministratorMutation) {
		m.oldValue = func(context.Context) (*Administrator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdministratorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdministratorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AdministratorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the "username" field.
func (m *AdministratorMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdministratorMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Administrator entity.
// If the Administrator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdministratorMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdministratorMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdministratorMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdministratorMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Administrator entity.
// If the Administrator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdministratorMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdministratorMutation) ResetPassword() {
	m.password = nil
}

// Op returns the operation name.
func (m *AdministratorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Administrator).
func (m *AdministratorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdministratorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, administrator.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, administrator.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdministratorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case administrator.FieldUsername:
		return m.Username()
	case administrator.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdministratorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case administrator.FieldUsername:
		return m.OldUsername(ctx)
	case administrator.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Administrator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdministratorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case administrator.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case administrator.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Administrator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdministratorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdministratorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdministratorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Administrator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdministratorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdministratorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdministratorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Administrator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdministratorMutation) ResetField(name string) error {
	switch name {
	case administrator.FieldUsername:
		m.ResetUsername()
		return nil
	case administrator.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Administrator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdministratorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdministratorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdministratorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdministratorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdministratorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdministratorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdministratorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Administrator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdministratorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Administrator edge %s", name)
}

// DeletedVlanLogMutation represents an operation that mutates the DeletedVlanLog nodes in the graph.
type DeletedVlanLogMutation struct {
	config
	op               Op
	typ              string
	id               *int
	vlan_id          *int
	addvlan_id       *int
	deleted          *bool
	clearedFields    map[string]struct{}
	on_device        *int
	clearedon_device bool
	done             bool
	oldValue         func(context.Context) (*DeletedVlanLog, error)
	predicates       []predicate.DeletedVlanLog
}

var _ ent.Mutation = (*DeletedVlanLogMutation)(nil)

// deletedvlanlogOption allows management of the mutation configuration using functional options.
type deletedvlanlogOption func(*DeletedVlanLogMutation)

// newDeletedVlanLogMutation creates new mutation for the DeletedVlanLog entity.
func newDeletedVlanLogMutation(c config, op Op, opts ...deletedvlanlogOption) *DeletedVlanLogMutation {
	m := &DeletedVlanLogMutation{
		config:        c,
		op:            op,
		typ:           TypeDeletedVlanLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeletedVlanLogID sets the ID field of the mutation.
func withDeletedVlanLogID(id int) deletedvlanlogOption {
	return func(m *DeletedVlanLogMutation) {
		var (
			err   error
			once  sync.Once
			value *DeletedVlanLog
		)
		m.oldValue = func(ctx context.Context) (*DeletedVlanLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeletedVlanLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeletedVlanLog sets the old DeletedVlanLog of the mutation.
func withDeletedVlanLog(node *DeletedVlanLog) deletedvlanlogOption {
	return func(m *DeletedVlanLogMutation) {
		m.oldValue = func(context.Context) (*DeletedVlanLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeletedVlanLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeletedVlanLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DeletedVlanLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetVlanID sets the "vlan_id" field.
func (m *DeletedVlanLogMutation) SetVlanID(i int) {
	m.vlan_id = &i
	m.addvlan_id = nil
}

// VlanID returns the value of the "vlan_id" field in the mutation.
func (m *DeletedVlanLogMutation) VlanID() (r int, exists bool) {
	v := m.vlan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVlanID returns the old "vlan_id" field's value of the DeletedVlanLog entity.
// If the DeletedVlanLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedVlanLogMutation) OldVlanID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlanID: %w", err)
	}
	return oldValue.VlanID, nil
}

// AddVlanID adds i to the "vlan_id" field.
func (m *DeletedVlanLogMutation) AddVlanID(i int) {
	if m.addvlan_id != nil {
		*m.addvlan_id += i
	} else {
		m.addvlan_id = &i
	}
}

// AddedVlanID returns the value that was added to the "vlan_id" field in this mutation.
func (m *DeletedVlanLogMutation) AddedVlanID() (r int, exists bool) {
	v := m.addvlan_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVlanID resets all changes to the "vlan_id" field.
func (m *DeletedVlanLogMutation) ResetVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
}

// SetDeleted sets the "deleted" field.
func (m *DeletedVlanLogMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *DeletedVlanLogMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the DeletedVlanLog entity.
// If the DeletedVlanLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeletedVlanLogMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *DeletedVlanLogMutation) ResetDeleted() {
	m.deleted = nil
}

// SetOnDeviceID sets the "on_device" edge to the Device entity by id.
func (m *DeletedVlanLogMutation) SetOnDeviceID(id int) {
	m.on_device = &id
}

// ClearOnDevice clears the "on_device" edge to the Device entity.
func (m *DeletedVlanLogMutation) ClearOnDevice() {
	m.clearedon_device = true
}

// OnDeviceCleared reports if the "on_device" edge to the Device entity was cleared.
func (m *DeletedVlanLogMutation) OnDeviceCleared() bool {
	return m.clearedon_device
}

// OnDeviceID returns the "on_device" edge ID in the mutation.
func (m *DeletedVlanLogMutation) OnDeviceID() (id int, exists bool) {
	if m.on_device != nil {
		return *m.on_device, true
	}
	return
}

// OnDeviceIDs returns the "on_device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OnDeviceID instead. It exists only for internal usage by the builders.
func (m *DeletedVlanLogMutation) OnDeviceIDs() (ids []int) {
	if id := m.on_device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOnDevice resets all changes to the "on_device" edge.
func (m *DeletedVlanLogMutation) ResetOnDevice() {
	m.on_device = nil
	m.clearedon_device = false
}

// Op returns the operation name.
func (m *DeletedVlanLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeletedVlanLog).
func (m *DeletedVlanLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeletedVlanLogMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.vlan_id != nil {
		fields = append(fields, deletedvlanlog.FieldVlanID)
	}
	if m.deleted != nil {
		fields = append(fields, deletedvlanlog.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeletedVlanLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deletedvlanlog.FieldVlanID:
		return m.VlanID()
	case deletedvlanlog.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeletedVlanLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deletedvlanlog.FieldVlanID:
		return m.OldVlanID(ctx)
	case deletedvlanlog.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown DeletedVlanLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeletedVlanLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deletedvlanlog.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlanID(v)
		return nil
	case deletedvlanlog.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown DeletedVlanLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeletedVlanLogMutation) AddedFields() []string {
	var fields []string
	if m.addvlan_id != nil {
		fields = append(fields, deletedvlanlog.FieldVlanID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeletedVlanLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deletedvlanlog.FieldVlanID:
		return m.AddedVlanID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeletedVlanLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deletedvlanlog.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlanID(v)
		return nil
	}
	return fmt.Errorf("unknown DeletedVlanLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeletedVlanLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeletedVlanLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeletedVlanLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeletedVlanLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeletedVlanLogMutation) ResetField(name string) error {
	switch name {
	case deletedvlanlog.FieldVlanID:
		m.ResetVlanID()
		return nil
	case deletedvlanlog.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown DeletedVlanLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeletedVlanLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.on_device != nil {
		edges = append(edges, deletedvlanlog.EdgeOnDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeletedVlanLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deletedvlanlog.EdgeOnDevice:
		if id := m.on_device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeletedVlanLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeletedVlanLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeletedVlanLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedon_device {
		edges = append(edges, deletedvlanlog.EdgeOnDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeletedVlanLogMutation) EdgeCleared(name string) bool {
	switch name {
	case deletedvlanlog.EdgeOnDevice:
		return m.clearedon_device
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeletedVlanLogMutation) ClearEdge(name string) error {
	switch name {
	case deletedvlanlog.EdgeOnDevice:
		m.ClearOnDevice()
		return nil
	}
	return fmt.Errorf("unknown DeletedVlanLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeletedVlanLogMutation) ResetEdge(name string) error {
	switch name {
	case deletedvlanlog.EdgeOnDevice:
		m.ResetOnDevice()
		return nil
	}
	return fmt.Errorf("unknown DeletedVlanLog edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	device_name          *string
	device_hostname      *string
	device_username      *string
	device_password      *string
	device_secret        *string
	device_ssh_port      *int
	adddevice_ssh_port   *int
	device_commit_config *bool
	clearedFields        map[string]struct{}
	in_type              *int
	clearedin_type       bool
	in_platform          *int
	clearedin_platform   bool
	interfaces           map[int]struct{}
	removedinterfaces    map[int]struct{}
	clearedinterfaces    bool
	po_interfaces        map[int]struct{}
	removedpo_interfaces map[int]struct{}
	clearedpo_interfaces bool
	in_topology          map[int]struct{}
	removedin_topology   map[int]struct{}
	clearedin_topology   bool
	store_vlans          map[int]struct{}
	removedstore_vlans   map[int]struct{}
	clearedstore_vlans   bool
	deleted_vlans        map[int]struct{}
	removeddeleted_vlans map[int]struct{}
	cleareddeleted_vlans bool
	done                 bool
	oldValue             func(context.Context) (*Device, error)
	predicates           []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDeviceName sets the "device_name" field.
func (m *DeviceMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *DeviceMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *DeviceMutation) ResetDeviceName() {
	m.device_name = nil
}

// SetDeviceHostname sets the "device_hostname" field.
func (m *DeviceMutation) SetDeviceHostname(s string) {
	m.device_hostname = &s
}

// DeviceHostname returns the value of the "device_hostname" field in the mutation.
func (m *DeviceMutation) DeviceHostname() (r string, exists bool) {
	v := m.device_hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceHostname returns the old "device_hostname" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceHostname: %w", err)
	}
	return oldValue.DeviceHostname, nil
}

// ResetDeviceHostname resets all changes to the "device_hostname" field.
func (m *DeviceMutation) ResetDeviceHostname() {
	m.device_hostname = nil
}

// SetDeviceUsername sets the "device_username" field.
func (m *DeviceMutation) SetDeviceUsername(s string) {
	m.device_username = &s
}

// DeviceUsername returns the value of the "device_username" field in the mutation.
func (m *DeviceMutation) DeviceUsername() (r string, exists bool) {
	v := m.device_username
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceUsername returns the old "device_username" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceUsername: %w", err)
	}
	return oldValue.DeviceUsername, nil
}

// ClearDeviceUsername clears the value of the "device_username" field.
func (m *DeviceMutation) ClearDeviceUsername() {
	m.device_username = nil
	m.clearedFields[device.FieldDeviceUsername] = struct{}{}
}

// DeviceUsernameCleared returns if the "device_username" field was cleared in this mutation.
func (m *DeviceMutation) DeviceUsernameCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceUsername]
	return ok
}

// ResetDeviceUsername resets all changes to the "device_username" field.
func (m *DeviceMutation) ResetDeviceUsername() {
	m.device_username = nil
	delete(m.clearedFields, device.FieldDeviceUsername)
}

// SetDevicePassword sets the "device_password" field.
func (m *DeviceMutation) SetDevicePassword(s string) {
	m.device_password = &s
}

// DevicePassword returns the value of the "device_password" field in the mutation.
func (m *DeviceMutation) DevicePassword() (r string, exists bool) {
	v := m.device_password
	if v == nil {
		return
	}
	return *v, true
}

// OldDevicePassword returns the old "device_password" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDevicePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDevicePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDevicePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevicePassword: %w", err)
	}
	return oldValue.DevicePassword, nil
}

// ClearDevicePassword clears the value of the "device_password" field.
func (m *DeviceMutation) ClearDevicePassword() {
	m.device_password = nil
	m.clearedFields[device.FieldDevicePassword] = struct{}{}
}

// DevicePasswordCleared returns if the "device_password" field was cleared in this mutation.
func (m *DeviceMutation) DevicePasswordCleared() bool {
	_, ok := m.clearedFields[device.FieldDevicePassword]
	return ok
}

// ResetDevicePassword resets all changes to the "device_password" field.
func (m *DeviceMutation) ResetDevicePassword() {
	m.device_password = nil
	delete(m.clearedFields, device.FieldDevicePassword)
}

// SetDeviceSecret sets the "device_secret" field.
func (m *DeviceMutation) SetDeviceSecret(s string) {
	m.device_secret = &s
}

// DeviceSecret returns the value of the "device_secret" field in the mutation.
func (m *DeviceMutation) DeviceSecret() (r string, exists bool) {
	v := m.device_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSecret returns the old "device_secret" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSecret: %w", err)
	}
	return oldValue.DeviceSecret, nil
}

// ClearDeviceSecret clears the value of the "device_secret" field.
func (m *DeviceMutation) ClearDeviceSecret() {
	m.device_secret = nil
	m.clearedFields[device.FieldDeviceSecret] = struct{}{}
}

// DeviceSecretCleared returns if the "device_secret" field was cleared in this mutation.
func (m *DeviceMutation) DeviceSecretCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceSecret]
	return ok
}

// ResetDeviceSecret resets all changes to the "device_secret" field.
func (m *DeviceMutation) ResetDeviceSecret() {
	m.device_secret = nil
	delete(m.clearedFields, device.FieldDeviceSecret)
}

// SetDeviceSSHPort sets the "device_ssh_port" field.
func (m *DeviceMutation) SetDeviceSSHPort(i int) {
	m.device_ssh_port = &i
	m.adddevice_ssh_port = nil
}

// DeviceSSHPort returns the value of the "device_ssh_port" field in the mutation.
func (m *DeviceMutation) DeviceSSHPort() (r int, exists bool) {
	v := m.device_ssh_port
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSSHPort returns the old "device_ssh_port" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceSSHPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceSSHPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceSSHPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSSHPort: %w", err)
	}
	return oldValue.DeviceSSHPort, nil
}

// AddDeviceSSHPort adds i to the "device_ssh_port" field.
func (m *DeviceMutation) AddDeviceSSHPort(i int) {
	if m.adddevice_ssh_port != nil {
		*m.adddevice_ssh_port += i
	} else {
		m.adddevice_ssh_port = &i
	}
}

// AddedDeviceSSHPort returns the value that was added to the "device_ssh_port" field in this mutation.
func (m *DeviceMutation) AddedDeviceSSHPort() (r int, exists bool) {
	v := m.adddevice_ssh_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceSSHPort resets all changes to the "device_ssh_port" field.
func (m *DeviceMutation) ResetDeviceSSHPort() {
	m.device_ssh_port = nil
	m.adddevice_ssh_port = nil
}

// SetDeviceCommitConfig sets the "device_commit_config" field.
func (m *DeviceMutation) SetDeviceCommitConfig(b bool) {
	m.device_commit_config = &b
}

// DeviceCommitConfig returns the value of the "device_commit_config" field in the mutation.
func (m *DeviceMutation) DeviceCommitConfig() (r bool, exists bool) {
	v := m.device_commit_config
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceCommitConfig returns the old "device_commit_config" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceCommitConfig(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceCommitConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceCommitConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceCommitConfig: %w", err)
	}
	return oldValue.DeviceCommitConfig, nil
}

// ResetDeviceCommitConfig resets all changes to the "device_commit_config" field.
func (m *DeviceMutation) ResetDeviceCommitConfig() {
	m.device_commit_config = nil
}

// SetInTypeID sets the "in_type" edge to the DeviceType entity by id.
func (m *DeviceMutation) SetInTypeID(id int) {
	m.in_type = &id
}

// ClearInType clears the "in_type" edge to the DeviceType entity.
func (m *DeviceMutation) ClearInType() {
	m.clearedin_type = true
}

// InTypeCleared reports if the "in_type" edge to the DeviceType entity was cleared.
func (m *DeviceMutation) InTypeCleared() bool {
	return m.clearedin_type
}

// InTypeID returns the "in_type" edge ID in the mutation.
func (m *DeviceMutation) InTypeID() (id int, exists bool) {
	if m.in_type != nil {
		return *m.in_type, true
	}
	return
}

// InTypeIDs returns the "in_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InTypeID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) InTypeIDs() (ids []int) {
	if id := m.in_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInType resets all changes to the "in_type" edge.
func (m *DeviceMutation) ResetInType() {
	m.in_type = nil
	m.clearedin_type = false
}

// SetInPlatformID sets the "in_platform" edge to the DevicePlatform entity by id.
func (m *DeviceMutation) SetInPlatformID(id int) {
	m.in_platform = &id
}

// ClearInPlatform clears the "in_platform" edge to the DevicePlatform entity.
func (m *DeviceMutation) ClearInPlatform() {
	m.clearedin_platform = true
}

// InPlatformCleared reports if the "in_platform" edge to the DevicePlatform entity was cleared.
func (m *DeviceMutation) InPlatformCleared() bool {
	return m.clearedin_platform
}

// InPlatformID returns the "in_platform" edge ID in the mutation.
func (m *DeviceMutation) InPlatformID() (id int, exists bool) {
	if m.in_platform != nil {
		return *m.in_platform, true
	}
	return
}

// InPlatformIDs returns the "in_platform" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InPlatformID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) InPlatformIDs() (ids []int) {
	if id := m.in_platform; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInPlatform resets all changes to the "in_platform" edge.
func (m *DeviceMutation) ResetInPlatform() {
	m.in_platform = nil
	m.clearedin_platform = false
}

// AddInterfaceIDs adds the "interfaces" edge to the NetInterface entity by ids.
func (m *DeviceMutation) AddInterfaceIDs(ids ...int) {
	if m.interfaces == nil {
		m.interfaces = make(map[int]struct{})
	}
	for i := range ids {
		m.interfaces[ids[i]] = struct{}{}
	}
}

// ClearInterfaces clears the "interfaces" edge to the NetInterface entity.
func (m *DeviceMutation) ClearInterfaces() {
	m.clearedinterfaces = true
}

// InterfacesCleared reports if the "interfaces" edge to the NetInterface entity was cleared.
func (m *DeviceMutation) InterfacesCleared() bool {
	return m.clearedinterfaces
}

// RemoveInterfaceIDs removes the "interfaces" edge to the NetInterface entity by IDs.
func (m *DeviceMutation) RemoveInterfaceIDs(ids ...int) {
	if m.removedinterfaces == nil {
		m.removedinterfaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinterfaces[ids[i]] = struct{}{}
	}
}

// RemovedInterfaces returns the removed IDs of the "interfaces" edge to the NetInterface entity.
func (m *DeviceMutation) RemovedInterfacesIDs() (ids []int) {
	for id := range m.removedinterfaces {
		ids = append(ids, id)
	}
	return
}

// InterfacesIDs returns the "interfaces" edge IDs in the mutation.
func (m *DeviceMutation) InterfacesIDs() (ids []int) {
	for id := range m.interfaces {
		ids = append(ids, id)
	}
	return
}

// ResetInterfaces resets all changes to the "interfaces" edge.
func (m *DeviceMutation) ResetInterfaces() {
	m.interfaces = nil
	m.clearedinterfaces = false
	m.removedinterfaces = nil
}

// AddPoInterfaceIDs adds the "po_interfaces" edge to the PortChannelInterface entity by ids.
func (m *DeviceMutation) AddPoInterfaceIDs(ids ...int) {
	if m.po_interfaces == nil {
		m.po_interfaces = make(map[int]struct{})
	}
	for i := range ids {
		m.po_interfaces[ids[i]] = struct{}{}
	}
}

// ClearPoInterfaces clears the "po_interfaces" edge to the PortChannelInterface entity.
func (m *DeviceMutation) ClearPoInterfaces() {
	m.clearedpo_interfaces = true
}

// PoInterfacesCleared reports if the "po_interfaces" edge to the PortChannelInterface entity was cleared.
func (m *DeviceMutation) PoInterfacesCleared() bool {
	return m.clearedpo_interfaces
}

// RemovePoInterfaceIDs removes the "po_interfaces" edge to the PortChannelInterface entity by IDs.
func (m *DeviceMutation) RemovePoInterfaceIDs(ids ...int) {
	if m.removedpo_interfaces == nil {
		m.removedpo_interfaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpo_interfaces[ids[i]] = struct{}{}
	}
}

// RemovedPoInterfaces returns the removed IDs of the "po_interfaces" edge to the PortChannelInterface entity.
func (m *DeviceMutation) RemovedPoInterfacesIDs() (ids []int) {
	for id := range m.removedpo_interfaces {
		ids = append(ids, id)
	}
	return
}

// PoInterfacesIDs returns the "po_interfaces" edge IDs in the mutation.
func (m *DeviceMutation) PoInterfacesIDs() (ids []int) {
	for id := range m.po_interfaces {
		ids = append(ids, id)
	}
	return
}

// ResetPoInterfaces resets all changes to the "po_interfaces" edge.
func (m *DeviceMutation) ResetPoInterfaces() {
	m.po_interfaces = nil
	m.clearedpo_interfaces = false
	m.removedpo_interfaces = nil
}

// AddInTopologyIDs adds the "in_topology" edge to the NetTopologyDeviceMap entity by ids.
func (m *DeviceMutation) AddInTopologyIDs(ids ...int) {
	if m.in_topology == nil {
		m.in_topology = make(map[int]struct{})
	}
	for i := range ids {
		m.in_topology[ids[i]] = struct{}{}
	}
}

// ClearInTopology clears the "in_topology" edge to the NetTopologyDeviceMap entity.
func (m *DeviceMutation) ClearInTopology() {
	m.clearedin_topology = true
}

// InTopologyCleared reports if the "in_topology" edge to the NetTopologyDeviceMap entity was cleared.
func (m *DeviceMutation) InTopologyCleared() bool {
	return m.clearedin_topology
}

// RemoveInTopologyIDs removes the "in_topology" edge to the NetTopologyDeviceMap entity by IDs.
func (m *DeviceMutation) RemoveInTopologyIDs(ids ...int) {
	if m.removedin_topology == nil {
		m.removedin_topology = make(map[int]struct{})
	}
	for i := range ids {
		m.removedin_topology[ids[i]] = struct{}{}
	}
}

// RemovedInTopology returns the removed IDs of the "in_topology" edge to the NetTopologyDeviceMap entity.
func (m *DeviceMutation) RemovedInTopologyIDs() (ids []int) {
	for id := range m.removedin_topology {
		ids = append(ids, id)
	}
	return
}

// InTopologyIDs returns the "in_topology" edge IDs in the mutation.
func (m *DeviceMutation) InTopologyIDs() (ids []int) {
	for id := range m.in_topology {
		ids = append(ids, id)
	}
	return
}

// ResetInTopology resets all changes to the "in_topology" edge.
func (m *DeviceMutation) ResetInTopology() {
	m.in_topology = nil
	m.clearedin_topology = false
	m.removedin_topology = nil
}

// AddStoreVlanIDs adds the "store_vlans" edge to the Vlan entity by ids.
func (m *DeviceMutation) AddStoreVlanIDs(ids ...int) {
	if m.store_vlans == nil {
		m.store_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.store_vlans[ids[i]] = struct{}{}
	}
}

// ClearStoreVlans clears the "store_vlans" edge to the Vlan entity.
func (m *DeviceMutation) ClearStoreVlans() {
	m.clearedstore_vlans = true
}

// StoreVlansCleared reports if the "store_vlans" edge to the Vlan entity was cleared.
func (m *DeviceMutation) StoreVlansCleared() bool {
	return m.clearedstore_vlans
}

// RemoveStoreVlanIDs removes the "store_vlans" edge to the Vlan entity by IDs.
func (m *DeviceMutation) RemoveStoreVlanIDs(ids ...int) {
	if m.removedstore_vlans == nil {
		m.removedstore_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstore_vlans[ids[i]] = struct{}{}
	}
}

// RemovedStoreVlans returns the removed IDs of the "store_vlans" edge to the Vlan entity.
func (m *DeviceMutation) RemovedStoreVlansIDs() (ids []int) {
	for id := range m.removedstore_vlans {
		ids = append(ids, id)
	}
	return
}

// StoreVlansIDs returns the "store_vlans" edge IDs in the mutation.
func (m *DeviceMutation) StoreVlansIDs() (ids []int) {
	for id := range m.store_vlans {
		ids = append(ids, id)
	}
	return
}

// ResetStoreVlans resets all changes to the "store_vlans" edge.
func (m *DeviceMutation) ResetStoreVlans() {
	m.store_vlans = nil
	m.clearedstore_vlans = false
	m.removedstore_vlans = nil
}

// AddDeletedVlanIDs adds the "deleted_vlans" edge to the DeletedVlanLog entity by ids.
func (m *DeviceMutation) AddDeletedVlanIDs(ids ...int) {
	if m.deleted_vlans == nil {
		m.deleted_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.deleted_vlans[ids[i]] = struct{}{}
	}
}

// ClearDeletedVlans clears the "deleted_vlans" edge to the DeletedVlanLog entity.
func (m *DeviceMutation) ClearDeletedVlans() {
	m.cleareddeleted_vlans = true
}

// DeletedVlansCleared reports if the "deleted_vlans" edge to the DeletedVlanLog entity was cleared.
func (m *DeviceMutation) DeletedVlansCleared() bool {
	return m.cleareddeleted_vlans
}

// RemoveDeletedVlanIDs removes the "deleted_vlans" edge to the DeletedVlanLog entity by IDs.
func (m *DeviceMutation) RemoveDeletedVlanIDs(ids ...int) {
	if m.removeddeleted_vlans == nil {
		m.removeddeleted_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddeleted_vlans[ids[i]] = struct{}{}
	}
}

// RemovedDeletedVlans returns the removed IDs of the "deleted_vlans" edge to the DeletedVlanLog entity.
func (m *DeviceMutation) RemovedDeletedVlansIDs() (ids []int) {
	for id := range m.removeddeleted_vlans {
		ids = append(ids, id)
	}
	return
}

// DeletedVlansIDs returns the "deleted_vlans" edge IDs in the mutation.
func (m *DeviceMutation) DeletedVlansIDs() (ids []int) {
	for id := range m.deleted_vlans {
		ids = append(ids, id)
	}
	return
}

// ResetDeletedVlans resets all changes to the "deleted_vlans" edge.
func (m *DeviceMutation) ResetDeletedVlans() {
	m.deleted_vlans = nil
	m.cleareddeleted_vlans = false
	m.removeddeleted_vlans = nil
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.device_name != nil {
		fields = append(fields, device.FieldDeviceName)
	}
	if m.device_hostname != nil {
		fields = append(fields, device.FieldDeviceHostname)
	}
	if m.device_username != nil {
		fields = append(fields, device.FieldDeviceUsername)
	}
	if m.device_password != nil {
		fields = append(fields, device.FieldDevicePassword)
	}
	if m.device_secret != nil {
		fields = append(fields, device.FieldDeviceSecret)
	}
	if m.device_ssh_port != nil {
		fields = append(fields, device.FieldDeviceSSHPort)
	}
	if m.device_commit_config != nil {
		fields = append(fields, device.FieldDeviceCommitConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDeviceName:
		return m.DeviceName()
	case device.FieldDeviceHostname:
		return m.DeviceHostname()
	case device.FieldDeviceUsername:
		return m.DeviceUsername()
	case device.FieldDevicePassword:
		return m.DevicePassword()
	case device.FieldDeviceSecret:
		return m.DeviceSecret()
	case device.FieldDeviceSSHPort:
		return m.DeviceSSHPort()
	case device.FieldDeviceCommitConfig:
		return m.DeviceCommitConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case device.FieldDeviceHostname:
		return m.OldDeviceHostname(ctx)
	case device.FieldDeviceUsername:
		return m.OldDeviceUsername(ctx)
	case device.FieldDevicePassword:
		return m.OldDevicePassword(ctx)
	case device.FieldDeviceSecret:
		return m.OldDeviceSecret(ctx)
	case device.FieldDeviceSSHPort:
		return m.OldDeviceSSHPort(ctx)
	case device.FieldDeviceCommitConfig:
		return m.OldDeviceCommitConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case device.FieldDeviceHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceHostname(v)
		return nil
	case device.FieldDeviceUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceUsername(v)
		return nil
	case device.FieldDevicePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevicePassword(v)
		return nil
	case device.FieldDeviceSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSecret(v)
		return nil
	case device.FieldDeviceSSHPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSSHPort(v)
		return nil
	case device.FieldDeviceCommitConfig:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceCommitConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_ssh_port != nil {
		fields = append(fields, device.FieldDeviceSSHPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDeviceSSHPort:
		return m.AddedDeviceSSHPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldDeviceSSHPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceSSHPort(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldDeviceUsername) {
		fields = append(fields, device.FieldDeviceUsername)
	}
	if m.FieldCleared(device.FieldDevicePassword) {
		fields = append(fields, device.FieldDevicePassword)
	}
	if m.FieldCleared(device.FieldDeviceSecret) {
		fields = append(fields, device.FieldDeviceSecret)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldDeviceUsername:
		m.ClearDeviceUsername()
		return nil
	case device.FieldDevicePassword:
		m.ClearDevicePassword()
		return nil
	case device.FieldDeviceSecret:
		m.ClearDeviceSecret()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case device.FieldDeviceHostname:
		m.ResetDeviceHostname()
		return nil
	case device.FieldDeviceUsername:
		m.ResetDeviceUsername()
		return nil
	case device.FieldDevicePassword:
		m.ResetDevicePassword()
		return nil
	case device.FieldDeviceSecret:
		m.ResetDeviceSecret()
		return nil
	case device.FieldDeviceSSHPort:
		m.ResetDeviceSSHPort()
		return nil
	case device.FieldDeviceCommitConfig:
		m.ResetDeviceCommitConfig()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.in_type != nil {
		edges = append(edges, device.EdgeInType)
	}
	if m.in_platform != nil {
		edges = append(edges, device.EdgeInPlatform)
	}
	if m.interfaces != nil {
		edges = append(edges, device.EdgeInterfaces)
	}
	if m.po_interfaces != nil {
		edges = append(edges, device.EdgePoInterfaces)
	}
	if m.in_topology != nil {
		edges = append(edges, device.EdgeInTopology)
	}
	if m.store_vlans != nil {
		edges = append(edges, device.EdgeStoreVlans)
	}
	if m.deleted_vlans != nil {
		edges = append(edges, device.EdgeDeletedVlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeInType:
		if id := m.in_type; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeInPlatform:
		if id := m.in_platform; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeInterfaces:
		ids := make([]ent.Value, 0, len(m.interfaces))
		for id := range m.interfaces {
			ids = append(ids, id)
		}
		return ids
	case device.EdgePoInterfaces:
		ids := make([]ent.Value, 0, len(m.po_interfaces))
		for id := range m.po_interfaces {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeInTopology:
		ids := make([]ent.Value, 0, len(m.in_topology))
		for id := range m.in_topology {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeStoreVlans:
		ids := make([]ent.Value, 0, len(m.store_vlans))
		for id := range m.store_vlans {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeletedVlans:
		ids := make([]ent.Value, 0, len(m.deleted_vlans))
		for id := range m.deleted_vlans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedinterfaces != nil {
		edges = append(edges, device.EdgeInterfaces)
	}
	if m.removedpo_interfaces != nil {
		edges = append(edges, device.EdgePoInterfaces)
	}
	if m.removedin_topology != nil {
		edges = append(edges, device.EdgeInTopology)
	}
	if m.removedstore_vlans != nil {
		edges = append(edges, device.EdgeStoreVlans)
	}
	if m.removeddeleted_vlans != nil {
		edges = append(edges, device.EdgeDeletedVlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeInterfaces:
		ids := make([]ent.Value, 0, len(m.removedinterfaces))
		for id := range m.removedinterfaces {
			ids = append(ids, id)
		}
		return ids
	case device.EdgePoInterfaces:
		ids := make([]ent.Value, 0, len(m.removedpo_interfaces))
		for id := range m.removedpo_interfaces {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeInTopology:
		ids := make([]ent.Value, 0, len(m.removedin_topology))
		for id := range m.removedin_topology {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeStoreVlans:
		ids := make([]ent.Value, 0, len(m.removedstore_vlans))
		for id := range m.removedstore_vlans {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeletedVlans:
		ids := make([]ent.Value, 0, len(m.removeddeleted_vlans))
		for id := range m.removeddeleted_vlans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedin_type {
		edges = append(edges, device.EdgeInType)
	}
	if m.clearedin_platform {
		edges = append(edges, device.EdgeInPlatform)
	}
	if m.clearedinterfaces {
		edges = append(edges, device.EdgeInterfaces)
	}
	if m.clearedpo_interfaces {
		edges = append(edges, device.EdgePoInterfaces)
	}
	if m.clearedin_topology {
		edges = append(edges, device.EdgeInTopology)
	}
	if m.clearedstore_vlans {
		edges = append(edges, device.EdgeStoreVlans)
	}
	if m.cleareddeleted_vlans {
		edges = append(edges, device.EdgeDeletedVlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeInType:
		return m.clearedin_type
	case device.EdgeInPlatform:
		return m.clearedin_platform
	case device.EdgeInterfaces:
		return m.clearedinterfaces
	case device.EdgePoInterfaces:
		return m.clearedpo_interfaces
	case device.EdgeInTopology:
		return m.clearedin_topology
	case device.EdgeStoreVlans:
		return m.clearedstore_vlans
	case device.EdgeDeletedVlans:
		return m.cleareddeleted_vlans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeInType:
		m.ClearInType()
		return nil
	case device.EdgeInPlatform:
		m.ClearInPlatform()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeInType:
		m.ResetInType()
		return nil
	case device.EdgeInPlatform:
		m.ResetInPlatform()
		return nil
	case device.EdgeInterfaces:
		m.ResetInterfaces()
		return nil
	case device.EdgePoInterfaces:
		m.ResetPoInterfaces()
		return nil
	case device.EdgeInTopology:
		m.ResetInTopology()
		return nil
	case device.EdgeStoreVlans:
		m.ResetStoreVlans()
		return nil
	case device.EdgeDeletedVlans:
		m.ResetDeletedVlans()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DevicePlatformMutation represents an operation that mutates the DevicePlatform nodes in the graph.
type DevicePlatformMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	device_platform_name *string
	clearedFields        map[string]struct{}
	platforms            map[int]struct{}
	removedplatforms     map[int]struct{}
	clearedplatforms     bool
	done                 bool
	oldValue             func(context.Context) (*DevicePlatform, error)
	predicates           []predicate.DevicePlatform
}

var _ ent.Mutation = (*DevicePlatformMutation)(nil)

// deviceplatformOption allows management of the mutation configuration using functional options.
type deviceplatformOption func(*DevicePlatformMutation)

// newDevicePlatformMutation creates new mutation for the DevicePlatform entity.
func newDevicePlatformMutation(c config, op Op, opts ...deviceplatformOption) *DevicePlatformMutation {
	m := &DevicePlatformMutation{
		config:        c,
		op:            op,
		typ:           TypeDevicePlatform,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDevicePlatformID sets the ID field of the mutation.
func withDevicePlatformID(id int) deviceplatformOption {
	return func(m *DevicePlatformMutation) {
		var (
			err   error
			once  sync.Once
			value *DevicePlatform
		)
		m.oldValue = func(ctx context.Context) (*DevicePlatform, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DevicePlatform.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevicePlatform sets the old DevicePlatform of the mutation.
func withDevicePlatform(node *DevicePlatform) deviceplatformOption {
	return func(m *DevicePlatformMutation) {
		m.oldValue = func(context.Context) (*DevicePlatform, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DevicePlatformMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DevicePlatformMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DevicePlatformMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDevicePlatformName sets the "device_platform_name" field.
func (m *DevicePlatformMutation) SetDevicePlatformName(s string) {
	m.device_platform_name = &s
}

// DevicePlatformName returns the value of the "device_platform_name" field in the mutation.
func (m *DevicePlatformMutation) DevicePlatformName() (r string, exists bool) {
	v := m.device_platform_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDevicePlatformName returns the old "device_platform_name" field's value of the DevicePlatform entity.
// If the DevicePlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DevicePlatformMutation) OldDevicePlatformName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDevicePlatformName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDevicePlatformName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevicePlatformName: %w", err)
	}
	return oldValue.DevicePlatformName, nil
}

// ResetDevicePlatformName resets all changes to the "device_platform_name" field.
func (m *DevicePlatformMutation) ResetDevicePlatformName() {
	m.device_platform_name = nil
}

// AddPlatformIDs adds the "platforms" edge to the Device entity by ids.
func (m *DevicePlatformMutation) AddPlatformIDs(ids ...int) {
	if m.platforms == nil {
		m.platforms = make(map[int]struct{})
	}
	for i := range ids {
		m.platforms[ids[i]] = struct{}{}
	}
}

// ClearPlatforms clears the "platforms" edge to the Device entity.
func (m *DevicePlatformMutation) ClearPlatforms() {
	m.clearedplatforms = true
}

// PlatformsCleared reports if the "platforms" edge to the Device entity was cleared.
func (m *DevicePlatformMutation) PlatformsCleared() bool {
	return m.clearedplatforms
}

// RemovePlatformIDs removes the "platforms" edge to the Device entity by IDs.
func (m *DevicePlatformMutation) RemovePlatformIDs(ids ...int) {
	if m.removedplatforms == nil {
		m.removedplatforms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplatforms[ids[i]] = struct{}{}
	}
}

// RemovedPlatforms returns the removed IDs of the "platforms" edge to the Device entity.
func (m *DevicePlatformMutation) RemovedPlatformsIDs() (ids []int) {
	for id := range m.removedplatforms {
		ids = append(ids, id)
	}
	return
}

// PlatformsIDs returns the "platforms" edge IDs in the mutation.
func (m *DevicePlatformMutation) PlatformsIDs() (ids []int) {
	for id := range m.platforms {
		ids = append(ids, id)
	}
	return
}

// ResetPlatforms resets all changes to the "platforms" edge.
func (m *DevicePlatformMutation) ResetPlatforms() {
	m.platforms = nil
	m.clearedplatforms = false
	m.removedplatforms = nil
}

// Op returns the operation name.
func (m *DevicePlatformMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DevicePlatform).
func (m *DevicePlatformMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DevicePlatformMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.device_platform_name != nil {
		fields = append(fields, deviceplatform.FieldDevicePlatformName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DevicePlatformMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceplatform.FieldDevicePlatformName:
		return m.DevicePlatformName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DevicePlatformMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceplatform.FieldDevicePlatformName:
		return m.OldDevicePlatformName(ctx)
	}
	return nil, fmt.Errorf("unknown DevicePlatform field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DevicePlatformMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceplatform.FieldDevicePlatformName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevicePlatformName(v)
		return nil
	}
	return fmt.Errorf("unknown DevicePlatform field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DevicePlatformMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DevicePlatformMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DevicePlatformMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DevicePlatform numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DevicePlatformMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DevicePlatformMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DevicePlatformMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DevicePlatform nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DevicePlatformMutation) ResetField(name string) error {
	switch name {
	case deviceplatform.FieldDevicePlatformName:
		m.ResetDevicePlatformName()
		return nil
	}
	return fmt.Errorf("unknown DevicePlatform field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DevicePlatformMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.platforms != nil {
		edges = append(edges, deviceplatform.EdgePlatforms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DevicePlatformMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceplatform.EdgePlatforms:
		ids := make([]ent.Value, 0, len(m.platforms))
		for id := range m.platforms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DevicePlatformMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplatforms != nil {
		edges = append(edges, deviceplatform.EdgePlatforms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DevicePlatformMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deviceplatform.EdgePlatforms:
		ids := make([]ent.Value, 0, len(m.removedplatforms))
		for id := range m.removedplatforms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DevicePlatformMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplatforms {
		edges = append(edges, deviceplatform.EdgePlatforms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DevicePlatformMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceplatform.EdgePlatforms:
		return m.clearedplatforms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DevicePlatformMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DevicePlatform unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DevicePlatformMutation) ResetEdge(name string) error {
	switch name {
	case deviceplatform.EdgePlatforms:
		m.ResetPlatforms()
		return nil
	}
	return fmt.Errorf("unknown DevicePlatform edge %s", name)
}

// DeviceTypeMutation represents an operation that mutates the DeviceType nodes in the graph.
type DeviceTypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	device_type_name *string
	clearedFields    map[string]struct{}
	types            map[int]struct{}
	removedtypes     map[int]struct{}
	clearedtypes     bool
	done             bool
	oldValue         func(context.Context) (*DeviceType, error)
	predicates       []predicate.DeviceType
}

var _ ent.Mutation = (*DeviceTypeMutation)(nil)

// devicetypeOption allows management of the mutation configuration using functional options.
type devicetypeOption func(*DeviceTypeMutation)

// newDeviceTypeMutation creates new mutation for the DeviceType entity.
func newDeviceTypeMutation(c config, op Op, opts ...devicetypeOption) *DeviceTypeMutation {
	m := &DeviceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceTypeID sets the ID field of the mutation.
func withDeviceTypeID(id int) devicetypeOption {
	return func(m *DeviceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceType
		)
		m.oldValue = func(ctx context.Context) (*DeviceType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceType sets the old DeviceType of the mutation.
func withDeviceType(node *DeviceType) devicetypeOption {
	return func(m *DeviceTypeMutation) {
		m.oldValue = func(context.Context) (*DeviceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DeviceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDeviceTypeName sets the "device_type_name" field.
func (m *DeviceTypeMutation) SetDeviceTypeName(s string) {
	m.device_type_name = &s
}

// DeviceTypeName returns the value of the "device_type_name" field in the mutation.
func (m *DeviceTypeMutation) DeviceTypeName() (r string, exists bool) {
	v := m.device_type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceTypeName returns the old "device_type_name" field's value of the DeviceType entity.
// If the DeviceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTypeMutation) OldDeviceTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceTypeName: %w", err)
	}
	return oldValue.DeviceTypeName, nil
}

// ResetDeviceTypeName resets all changes to the "device_type_name" field.
func (m *DeviceTypeMutation) ResetDeviceTypeName() {
	m.device_type_name = nil
}

// AddTypeIDs adds the "types" edge to the Device entity by ids.
func (m *DeviceTypeMutation) AddTypeIDs(ids ...int) {
	if m.types == nil {
		m.types = make(map[int]struct{})
	}
	for i := range ids {
		m.types[ids[i]] = struct{}{}
	}
}

// ClearTypes clears the "types" edge to the Device entity.
func (m *DeviceTypeMutation) ClearTypes() {
	m.clearedtypes = true
}

// TypesCleared reports if the "types" edge to the Device entity was cleared.
func (m *DeviceTypeMutation) TypesCleared() bool {
	return m.clearedtypes
}

// RemoveTypeIDs removes the "types" edge to the Device entity by IDs.
func (m *DeviceTypeMutation) RemoveTypeIDs(ids ...int) {
	if m.removedtypes == nil {
		m.removedtypes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtypes[ids[i]] = struct{}{}
	}
}

// RemovedTypes returns the removed IDs of the "types" edge to the Device entity.
func (m *DeviceTypeMutation) RemovedTypesIDs() (ids []int) {
	for id := range m.removedtypes {
		ids = append(ids, id)
	}
	return
}

// TypesIDs returns the "types" edge IDs in the mutation.
func (m *DeviceTypeMutation) TypesIDs() (ids []int) {
	for id := range m.types {
		ids = append(ids, id)
	}
	return
}

// ResetTypes resets all changes to the "types" edge.
func (m *DeviceTypeMutation) ResetTypes() {
	m.types = nil
	m.clearedtypes = false
	m.removedtypes = nil
}

// Op returns the operation name.
func (m *DeviceTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeviceType).
func (m *DeviceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.device_type_name != nil {
		fields = append(fields, devicetype.FieldDeviceTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicetype.FieldDeviceTypeName:
		return m.DeviceTypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicetype.FieldDeviceTypeName:
		return m.OldDeviceTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicetype.FieldDeviceTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceTypeMutation) ResetField(name string) error {
	switch name {
	case devicetype.FieldDeviceTypeName:
		m.ResetDeviceTypeName()
		return nil
	}
	return fmt.Errorf("unknown DeviceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.types != nil {
		edges = append(edges, devicetype.EdgeTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicetype.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.types))
		for id := range m.types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtypes != nil {
		edges = append(edges, devicetype.EdgeTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case devicetype.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.removedtypes))
		for id := range m.removedtypes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtypes {
		edges = append(edges, devicetype.EdgeTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case devicetype.EdgeTypes:
		return m.clearedtypes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceTypeMutation) ResetEdge(name string) error {
	switch name {
	case devicetype.EdgeTypes:
		m.ResetTypes()
		return nil
	}
	return fmt.Errorf("unknown DeviceType edge %s", name)
}

// NetInterfaceMutation represents an operation that mutates the NetInterface nodes in the graph.
type NetInterfaceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	interface_name         *string
	interface_shutdown     *bool
	clearedFields          map[string]struct{}
	on_device              *int
	clearedon_device       bool
	on_po_interface        *int
	clearedon_po_interface bool
	mode                   *int
	clearedmode            bool
	have_vlans             map[int]struct{}
	removedhave_vlans      map[int]struct{}
	clearedhave_vlans      bool
	native_on_vlan         *int
	clearednative_on_vlan  bool
	done                   bool
	oldValue               func(context.Context) (*NetInterface, error)
	predicates             []predicate.NetInterface
}

var _ ent.Mutation = (*NetInterfaceMutation)(nil)

// netinterfaceOption allows management of the mutation configuration using functional options.
type netinterfaceOption func(*NetInterfaceMutation)

// newNetInterfaceMutation creates new mutation for the NetInterface entity.
func newNetInterfaceMutation(c config, op Op, opts ...netinterfaceOption) *NetInterfaceMutation {
	m := &NetInterfaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNetInterface,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetInterfaceID sets the ID field of the mutation.
func withNetInterfaceID(id int) netinterfaceOption {
	return func(m *NetInterfaceMutation) {
		var (
			err   error
			once  sync.Once
			value *NetInterface
		)
		m.oldValue = func(ctx context.Context) (*NetInterface, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetInterface.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetInterface sets the old NetInterface of the mutation.
func withNetInterface(node *NetInterface) netinterfaceOption {
	return func(m *NetInterfaceMutation) {
		m.oldValue = func(context.Context) (*NetInterface, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetInterfaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetInterfaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetInterfaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInterfaceName sets the "interface_name" field.
func (m *NetInterfaceMutation) SetInterfaceName(s string) {
	m.interface_name = &s
}

// InterfaceName returns the value of the "interface_name" field in the mutation.
func (m *NetInterfaceMutation) InterfaceName() (r string, exists bool) {
	v := m.interface_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceName returns the old "interface_name" field's value of the NetInterface entity.
// If the NetInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetInterfaceMutation) OldInterfaceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInterfaceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInterfaceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceName: %w", err)
	}
	return oldValue.InterfaceName, nil
}

// ResetInterfaceName resets all changes to the "interface_name" field.
func (m *NetInterfaceMutation) ResetInterfaceName() {
	m.interface_name = nil
}

// SetInterfaceShutdown sets the "interface_shutdown" field.
func (m *NetInterfaceMutation) SetInterfaceShutdown(b bool) {
	m.interface_shutdown = &b
}

// InterfaceShutdown returns the value of the "interface_shutdown" field in the mutation.
func (m *NetInterfaceMutation) InterfaceShutdown() (r bool, exists bool) {
	v := m.interface_shutdown
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceShutdown returns the old "interface_shutdown" field's value of the NetInterface entity.
// If the NetInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetInterfaceMutation) OldInterfaceShutdown(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInterfaceShutdown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInterfaceShutdown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceShutdown: %w", err)
	}
	return oldValue.InterfaceShutdown, nil
}

// ResetInterfaceShutdown resets all changes to the "interface_shutdown" field.
func (m *NetInterfaceMutation) ResetInterfaceShutdown() {
	m.interface_shutdown = nil
}

// SetOnDeviceID sets the "on_device" edge to the Device entity by id.
func (m *NetInterfaceMutation) SetOnDeviceID(id int) {
	m.on_device = &id
}

// ClearOnDevice clears the "on_device" edge to the Device entity.
func (m *NetInterfaceMutation) ClearOnDevice() {
	m.clearedon_device = true
}

// OnDeviceCleared reports if the "on_device" edge to the Device entity was cleared.
func (m *NetInterfaceMutation) OnDeviceCleared() bool {
	return m.clearedon_device
}

// OnDeviceID returns the "on_device" edge ID in the mutation.
func (m *NetInterfaceMutation) OnDeviceID() (id int, exists bool) {
	if m.on_device != nil {
		return *m.on_device, true
	}
	return
}

// OnDeviceIDs returns the "on_device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OnDeviceID instead. It exists only for internal usage by the builders.
func (m *NetInterfaceMutation) OnDeviceIDs() (ids []int) {
	if id := m.on_device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOnDevice resets all changes to the "on_device" edge.
func (m *NetInterfaceMutation) ResetOnDevice() {
	m.on_device = nil
	m.clearedon_device = false
}

// SetOnPoInterfaceID sets the "on_po_interface" edge to the PortChannelInterface entity by id.
func (m *NetInterfaceMutation) SetOnPoInterfaceID(id int) {
	m.on_po_interface = &id
}

// ClearOnPoInterface clears the "on_po_interface" edge to the PortChannelInterface entity.
func (m *NetInterfaceMutation) ClearOnPoInterface() {
	m.clearedon_po_interface = true
}

// OnPoInterfaceCleared reports if the "on_po_interface" edge to the PortChannelInterface entity was cleared.
func (m *NetInterfaceMutation) OnPoInterfaceCleared() bool {
	return m.clearedon_po_interface
}

// OnPoInterfaceID returns the "on_po_interface" edge ID in the mutation.
func (m *NetInterfaceMutation) OnPoInterfaceID() (id int, exists bool) {
	if m.on_po_interface != nil {
		return *m.on_po_interface, true
	}
	return
}

// OnPoInterfaceIDs returns the "on_po_interface" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OnPoInterfaceID instead. It exists only for internal usage by the builders.
func (m *NetInterfaceMutation) OnPoInterfaceIDs() (ids []int) {
	if id := m.on_po_interface; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOnPoInterface resets all changes to the "on_po_interface" edge.
func (m *NetInterfaceMutation) ResetOnPoInterface() {
	m.on_po_interface = nil
	m.clearedon_po_interface = false
}

// SetModeID sets the "mode" edge to the NetInterfaceMode entity by id.
func (m *NetInterfaceMutation) SetModeID(id int) {
	m.mode = &id
}

// ClearMode clears the "mode" edge to the NetInterfaceMode entity.
func (m *NetInterfaceMutation) ClearMode() {
	m.clearedmode = true
}

// ModeCleared reports if the "mode" edge to the NetInterfaceMode entity was cleared.
func (m *NetInterfaceMutation) ModeCleared() bool {
	return m.clearedmode
}

// ModeID returns the "mode" edge ID in the mutation.
func (m *NetInterfaceMutation) ModeID() (id int, exists bool) {
	if m.mode != nil {
		return *m.mode, true
	}
	return
}

// ModeIDs returns the "mode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModeID instead. It exists only for internal usage by the builders.
func (m *NetInterfaceMutation) ModeIDs() (ids []int) {
	if id := m.mode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMode resets all changes to the "mode" edge.
func (m *NetInterfaceMutation) ResetMode() {
	m.mode = nil
	m.clearedmode = false
}

// AddHaveVlanIDs adds the "have_vlans" edge to the Vlan entity by ids.
func (m *NetInterfaceMutation) AddHaveVlanIDs(ids ...int) {
	if m.have_vlans == nil {
		m.have_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.have_vlans[ids[i]] = struct{}{}
	}
}

// ClearHaveVlans clears the "have_vlans" edge to the Vlan entity.
func (m *NetInterfaceMutation) ClearHaveVlans() {
	m.clearedhave_vlans = true
}

// HaveVlansCleared reports if the "have_vlans" edge to the Vlan entity was cleared.
func (m *NetInterfaceMutation) HaveVlansCleared() bool {
	return m.clearedhave_vlans
}

// RemoveHaveVlanIDs removes the "have_vlans" edge to the Vlan entity by IDs.
func (m *NetInterfaceMutation) RemoveHaveVlanIDs(ids ...int) {
	if m.removedhave_vlans == nil {
		m.removedhave_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhave_vlans[ids[i]] = struct{}{}
	}
}

// RemovedHaveVlans returns the removed IDs of the "have_vlans" edge to the Vlan entity.
func (m *NetInterfaceMutation) RemovedHaveVlansIDs() (ids []int) {
	for id := range m.removedhave_vlans {
		ids = append(ids, id)
	}
	return
}

// HaveVlansIDs returns the "have_vlans" edge IDs in the mutation.
func (m *NetInterfaceMutation) HaveVlansIDs() (ids []int) {
	for id := range m.have_vlans {
		ids = append(ids, id)
	}
	return
}

// ResetHaveVlans resets all changes to the "have_vlans" edge.
func (m *NetInterfaceMutation) ResetHaveVlans() {
	m.have_vlans = nil
	m.clearedhave_vlans = false
	m.removedhave_vlans = nil
}

// SetNativeOnVlanID sets the "native_on_vlan" edge to the Vlan entity by id.
func (m *NetInterfaceMutation) SetNativeOnVlanID(id int) {
	m.native_on_vlan = &id
}

// ClearNativeOnVlan clears the "native_on_vlan" edge to the Vlan entity.
func (m *NetInterfaceMutation) ClearNativeOnVlan() {
	m.clearednative_on_vlan = true
}

// NativeOnVlanCleared reports if the "native_on_vlan" edge to the Vlan entity was cleared.
func (m *NetInterfaceMutation) NativeOnVlanCleared() bool {
	return m.clearednative_on_vlan
}

// NativeOnVlanID returns the "native_on_vlan" edge ID in the mutation.
func (m *NetInterfaceMutation) NativeOnVlanID() (id int, exists bool) {
	if m.native_on_vlan != nil {
		return *m.native_on_vlan, true
	}
	return
}

// NativeOnVlanIDs returns the "native_on_vlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NativeOnVlanID instead. It exists only for internal usage by the builders.
func (m *NetInterfaceMutation) NativeOnVlanIDs() (ids []int) {
	if id := m.native_on_vlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNativeOnVlan resets all changes to the "native_on_vlan" edge.
func (m *NetInterfaceMutation) ResetNativeOnVlan() {
	m.native_on_vlan = nil
	m.clearednative_on_vlan = false
}

// Op returns the operation name.
func (m *NetInterfaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetInterface).
func (m *NetInterfaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetInterfaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.interface_name != nil {
		fields = append(fields, netinterface.FieldInterfaceName)
	}
	if m.interface_shutdown != nil {
		fields = append(fields, netinterface.FieldInterfaceShutdown)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetInterfaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case netinterface.FieldInterfaceName:
		return m.InterfaceName()
	case netinterface.FieldInterfaceShutdown:
		return m.InterfaceShutdown()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetInterfaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case netinterface.FieldInterfaceName:
		return m.OldInterfaceName(ctx)
	case netinterface.FieldInterfaceShutdown:
		return m.OldInterfaceShutdown(ctx)
	}
	return nil, fmt.Errorf("unknown NetInterface field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetInterfaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case netinterface.FieldInterfaceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceName(v)
		return nil
	case netinterface.FieldInterfaceShutdown:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceShutdown(v)
		return nil
	}
	return fmt.Errorf("unknown NetInterface field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetInterfaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetInterfaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetInterfaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetInterface numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetInterfaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetInterfaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetInterfaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetInterface nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetInterfaceMutation) ResetField(name string) error {
	switch name {
	case netinterface.FieldInterfaceName:
		m.ResetInterfaceName()
		return nil
	case netinterface.FieldInterfaceShutdown:
		m.ResetInterfaceShutdown()
		return nil
	}
	return fmt.Errorf("unknown NetInterface field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetInterfaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.on_device != nil {
		edges = append(edges, netinterface.EdgeOnDevice)
	}
	if m.on_po_interface != nil {
		edges = append(edges, netinterface.EdgeOnPoInterface)
	}
	if m.mode != nil {
		edges = append(edges, netinterface.EdgeMode)
	}
	if m.have_vlans != nil {
		edges = append(edges, netinterface.EdgeHaveVlans)
	}
	if m.native_on_vlan != nil {
		edges = append(edges, netinterface.EdgeNativeOnVlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetInterfaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case netinterface.EdgeOnDevice:
		if id := m.on_device; id != nil {
			return []ent.Value{*id}
		}
	case netinterface.EdgeOnPoInterface:
		if id := m.on_po_interface; id != nil {
			return []ent.Value{*id}
		}
	case netinterface.EdgeMode:
		if id := m.mode; id != nil {
			return []ent.Value{*id}
		}
	case netinterface.EdgeHaveVlans:
		ids := make([]ent.Value, 0, len(m.have_vlans))
		for id := range m.have_vlans {
			ids = append(ids, id)
		}
		return ids
	case netinterface.EdgeNativeOnVlan:
		if id := m.native_on_vlan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetInterfaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedhave_vlans != nil {
		edges = append(edges, netinterface.EdgeHaveVlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetInterfaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case netinterface.EdgeHaveVlans:
		ids := make([]ent.Value, 0, len(m.removedhave_vlans))
		for id := range m.removedhave_vlans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetInterfaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedon_device {
		edges = append(edges, netinterface.EdgeOnDevice)
	}
	if m.clearedon_po_interface {
		edges = append(edges, netinterface.EdgeOnPoInterface)
	}
	if m.clearedmode {
		edges = append(edges, netinterface.EdgeMode)
	}
	if m.clearedhave_vlans {
		edges = append(edges, netinterface.EdgeHaveVlans)
	}
	if m.clearednative_on_vlan {
		edges = append(edges, netinterface.EdgeNativeOnVlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetInterfaceMutation) EdgeCleared(name string) bool {
	switch name {
	case netinterface.EdgeOnDevice:
		return m.clearedon_device
	case netinterface.EdgeOnPoInterface:
		return m.clearedon_po_interface
	case netinterface.EdgeMode:
		return m.clearedmode
	case netinterface.EdgeHaveVlans:
		return m.clearedhave_vlans
	case netinterface.EdgeNativeOnVlan:
		return m.clearednative_on_vlan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetInterfaceMutation) ClearEdge(name string) error {
	switch name {
	case netinterface.EdgeOnDevice:
		m.ClearOnDevice()
		return nil
	case netinterface.EdgeOnPoInterface:
		m.ClearOnPoInterface()
		return nil
	case netinterface.EdgeMode:
		m.ClearMode()
		return nil
	case netinterface.EdgeNativeOnVlan:
		m.ClearNativeOnVlan()
		return nil
	}
	return fmt.Errorf("unknown NetInterface unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetInterfaceMutation) ResetEdge(name string) error {
	switch name {
	case netinterface.EdgeOnDevice:
		m.ResetOnDevice()
		return nil
	case netinterface.EdgeOnPoInterface:
		m.ResetOnPoInterface()
		return nil
	case netinterface.EdgeMode:
		m.ResetMode()
		return nil
	case netinterface.EdgeHaveVlans:
		m.ResetHaveVlans()
		return nil
	case netinterface.EdgeNativeOnVlan:
		m.ResetNativeOnVlan()
		return nil
	}
	return fmt.Errorf("unknown NetInterface edge %s", name)
}

// NetInterfaceModeMutation represents an operation that mutates the NetInterfaceMode nodes in the graph.
type NetInterfaceModeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	interface_mode  *string
	clearedFields   map[string]struct{}
	modes           map[int]struct{}
	removedmodes    map[int]struct{}
	clearedmodes    bool
	po_modes        map[int]struct{}
	removedpo_modes map[int]struct{}
	clearedpo_modes bool
	done            bool
	oldValue        func(context.Context) (*NetInterfaceMode, error)
	predicates      []predicate.NetInterfaceMode
}

var _ ent.Mutation = (*NetInterfaceModeMutation)(nil)

// netinterfacemodeOption allows management of the mutation configuration using functional options.
type netinterfacemodeOption func(*NetInterfaceModeMutation)

// newNetInterfaceModeMutation creates new mutation for the NetInterfaceMode entity.
func newNetInterfaceModeMutation(c config, op Op, opts ...netinterfacemodeOption) *NetInterfaceModeMutation {
	m := &NetInterfaceModeMutation{
		config:        c,
		op:            op,
		typ:           TypeNetInterfaceMode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetInterfaceModeID sets the ID field of the mutation.
func withNetInterfaceModeID(id int) netinterfacemodeOption {
	return func(m *NetInterfaceModeMutation) {
		var (
			err   error
			once  sync.Once
			value *NetInterfaceMode
		)
		m.oldValue = func(ctx context.Context) (*NetInterfaceMode, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetInterfaceMode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetInterfaceMode sets the old NetInterfaceMode of the mutation.
func withNetInterfaceMode(node *NetInterfaceMode) netinterfacemodeOption {
	return func(m *NetInterfaceModeMutation) {
		m.oldValue = func(context.Context) (*NetInterfaceMode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetInterfaceModeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetInterfaceModeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetInterfaceModeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInterfaceMode sets the "interface_mode" field.
func (m *NetInterfaceModeMutation) SetInterfaceMode(s string) {
	m.interface_mode = &s
}

// InterfaceMode returns the value of the "interface_mode" field in the mutation.
func (m *NetInterfaceModeMutation) InterfaceMode() (r string, exists bool) {
	v := m.interface_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceMode returns the old "interface_mode" field's value of the NetInterfaceMode entity.
// If the NetInterfaceMode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetInterfaceModeMutation) OldInterfaceMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInterfaceMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInterfaceMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceMode: %w", err)
	}
	return oldValue.InterfaceMode, nil
}

// ResetInterfaceMode resets all changes to the "interface_mode" field.
func (m *NetInterfaceModeMutation) ResetInterfaceMode() {
	m.interface_mode = nil
}

// AddModeIDs adds the "modes" edge to the NetInterface entity by ids.
func (m *NetInterfaceModeMutation) AddModeIDs(ids ...int) {
	if m.modes == nil {
		m.modes = make(map[int]struct{})
	}
	for i := range ids {
		m.modes[ids[i]] = struct{}{}
	}
}

// ClearModes clears the "modes" edge to the NetInterface entity.
func (m *NetInterfaceModeMutation) ClearModes() {
	m.clearedmodes = true
}

// ModesCleared reports if the "modes" edge to the NetInterface entity was cleared.
func (m *NetInterfaceModeMutation) ModesCleared() bool {
	return m.clearedmodes
}

// RemoveModeIDs removes the "modes" edge to the NetInterface entity by IDs.
func (m *NetInterfaceModeMutation) RemoveModeIDs(ids ...int) {
	if m.removedmodes == nil {
		m.removedmodes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmodes[ids[i]] = struct{}{}
	}
}

// RemovedModes returns the removed IDs of the "modes" edge to the NetInterface entity.
func (m *NetInterfaceModeMutation) RemovedModesIDs() (ids []int) {
	for id := range m.removedmodes {
		ids = append(ids, id)
	}
	return
}

// ModesIDs returns the "modes" edge IDs in the mutation.
func (m *NetInterfaceModeMutation) ModesIDs() (ids []int) {
	for id := range m.modes {
		ids = append(ids, id)
	}
	return
}

// ResetModes resets all changes to the "modes" edge.
func (m *NetInterfaceModeMutation) ResetModes() {
	m.modes = nil
	m.clearedmodes = false
	m.removedmodes = nil
}

// AddPoModeIDs adds the "po_modes" edge to the PortChannelInterface entity by ids.
func (m *NetInterfaceModeMutation) AddPoModeIDs(ids ...int) {
	if m.po_modes == nil {
		m.po_modes = make(map[int]struct{})
	}
	for i := range ids {
		m.po_modes[ids[i]] = struct{}{}
	}
}

// ClearPoModes clears the "po_modes" edge to the PortChannelInterface entity.
func (m *NetInterfaceModeMutation) ClearPoModes() {
	m.clearedpo_modes = true
}

// PoModesCleared reports if the "po_modes" edge to the PortChannelInterface entity was cleared.
func (m *NetInterfaceModeMutation) PoModesCleared() bool {
	return m.clearedpo_modes
}

// RemovePoModeIDs removes the "po_modes" edge to the PortChannelInterface entity by IDs.
func (m *NetInterfaceModeMutation) RemovePoModeIDs(ids ...int) {
	if m.removedpo_modes == nil {
		m.removedpo_modes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpo_modes[ids[i]] = struct{}{}
	}
}

// RemovedPoModes returns the removed IDs of the "po_modes" edge to the PortChannelInterface entity.
func (m *NetInterfaceModeMutation) RemovedPoModesIDs() (ids []int) {
	for id := range m.removedpo_modes {
		ids = append(ids, id)
	}
	return
}

// PoModesIDs returns the "po_modes" edge IDs in the mutation.
func (m *NetInterfaceModeMutation) PoModesIDs() (ids []int) {
	for id := range m.po_modes {
		ids = append(ids, id)
	}
	return
}

// ResetPoModes resets all changes to the "po_modes" edge.
func (m *NetInterfaceModeMutation) ResetPoModes() {
	m.po_modes = nil
	m.clearedpo_modes = false
	m.removedpo_modes = nil
}

// Op returns the operation name.
func (m *NetInterfaceModeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetInterfaceMode).
func (m *NetInterfaceModeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetInterfaceModeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.interface_mode != nil {
		fields = append(fields, netinterfacemode.FieldInterfaceMode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetInterfaceModeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case netinterfacemode.FieldInterfaceMode:
		return m.InterfaceMode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetInterfaceModeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case netinterfacemode.FieldInterfaceMode:
		return m.OldInterfaceMode(ctx)
	}
	return nil, fmt.Errorf("unknown NetInterfaceMode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetInterfaceModeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case netinterfacemode.FieldInterfaceMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceMode(v)
		return nil
	}
	return fmt.Errorf("unknown NetInterfaceMode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetInterfaceModeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetInterfaceModeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetInterfaceModeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetInterfaceMode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetInterfaceModeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetInterfaceModeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetInterfaceModeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetInterfaceMode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetInterfaceModeMutation) ResetField(name string) error {
	switch name {
	case netinterfacemode.FieldInterfaceMode:
		m.ResetInterfaceMode()
		return nil
	}
	return fmt.Errorf("unknown NetInterfaceMode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetInterfaceModeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.modes != nil {
		edges = append(edges, netinterfacemode.EdgeModes)
	}
	if m.po_modes != nil {
		edges = append(edges, netinterfacemode.EdgePoModes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetInterfaceModeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case netinterfacemode.EdgeModes:
		ids := make([]ent.Value, 0, len(m.modes))
		for id := range m.modes {
			ids = append(ids, id)
		}
		return ids
	case netinterfacemode.EdgePoModes:
		ids := make([]ent.Value, 0, len(m.po_modes))
		for id := range m.po_modes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetInterfaceModeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmodes != nil {
		edges = append(edges, netinterfacemode.EdgeModes)
	}
	if m.removedpo_modes != nil {
		edges = append(edges, netinterfacemode.EdgePoModes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetInterfaceModeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case netinterfacemode.EdgeModes:
		ids := make([]ent.Value, 0, len(m.removedmodes))
		for id := range m.removedmodes {
			ids = append(ids, id)
		}
		return ids
	case netinterfacemode.EdgePoModes:
		ids := make([]ent.Value, 0, len(m.removedpo_modes))
		for id := range m.removedpo_modes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetInterfaceModeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmodes {
		edges = append(edges, netinterfacemode.EdgeModes)
	}
	if m.clearedpo_modes {
		edges = append(edges, netinterfacemode.EdgePoModes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetInterfaceModeMutation) EdgeCleared(name string) bool {
	switch name {
	case netinterfacemode.EdgeModes:
		return m.clearedmodes
	case netinterfacemode.EdgePoModes:
		return m.clearedpo_modes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetInterfaceModeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NetInterfaceMode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetInterfaceModeMutation) ResetEdge(name string) error {
	switch name {
	case netinterfacemode.EdgeModes:
		m.ResetModes()
		return nil
	case netinterfacemode.EdgePoModes:
		m.ResetPoModes()
		return nil
	}
	return fmt.Errorf("unknown NetInterfaceMode edge %s", name)
}

// NetTopologyMutation represents an operation that mutates the NetTopology nodes in the graph.
type NetTopologyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	topology_name        *string
	topology_description *string
	clearedFields        map[string]struct{}
	topology             map[int]struct{}
	removedtopology      map[int]struct{}
	clearedtopology      bool
	done                 bool
	oldValue             func(context.Context) (*NetTopology, error)
	predicates           []predicate.NetTopology
}

var _ ent.Mutation = (*NetTopologyMutation)(nil)

// nettopologyOption allows management of the mutation configuration using functional options.
type nettopologyOption func(*NetTopologyMutation)

// newNetTopologyMutation creates new mutation for the NetTopology entity.
func newNetTopologyMutation(c config, op Op, opts ...nettopologyOption) *NetTopologyMutation {
	m := &NetTopologyMutation{
		config:        c,
		op:            op,
		typ:           TypeNetTopology,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetTopologyID sets the ID field of the mutation.
func withNetTopologyID(id int) nettopologyOption {
	return func(m *NetTopologyMutation) {
		var (
			err   error
			once  sync.Once
			value *NetTopology
		)
		m.oldValue = func(ctx context.Context) (*NetTopology, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetTopology.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetTopology sets the old NetTopology of the mutation.
func withNetTopology(node *NetTopology) nettopologyOption {
	return func(m *NetTopologyMutation) {
		m.oldValue = func(context.Context) (*NetTopology, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetTopologyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetTopologyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetTopologyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTopologyName sets the "topology_name" field.
func (m *NetTopologyMutation) SetTopologyName(s string) {
	m.topology_name = &s
}

// TopologyName returns the value of the "topology_name" field in the mutation.
func (m *NetTopologyMutation) TopologyName() (r string, exists bool) {
	v := m.topology_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTopologyName returns the old "topology_name" field's value of the NetTopology entity.
// If the NetTopology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetTopologyMutation) OldTopologyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTopologyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTopologyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopologyName: %w", err)
	}
	return oldValue.TopologyName, nil
}

// ResetTopologyName resets all changes to the "topology_name" field.
func (m *NetTopologyMutation) ResetTopologyName() {
	m.topology_name = nil
}

// SetTopologyDescription sets the "topology_description" field.
func (m *NetTopologyMutation) SetTopologyDescription(s string) {
	m.topology_description = &s
}

// TopologyDescription returns the value of the "topology_description" field in the mutation.
func (m *NetTopologyMutation) TopologyDescription() (r string, exists bool) {
	v := m.topology_description
	if v == nil {
		return
	}
	return *v, true
}

// OldTopologyDescription returns the old "topology_description" field's value of the NetTopology entity.
// If the NetTopology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetTopologyMutation) OldTopologyDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTopologyDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTopologyDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopologyDescription: %w", err)
	}
	return oldValue.TopologyDescription, nil
}

// ResetTopologyDescription resets all changes to the "topology_description" field.
func (m *NetTopologyMutation) ResetTopologyDescription() {
	m.topology_description = nil
}

// AddTopologyIDs adds the "topology" edge to the NetTopologyDeviceMap entity by ids.
func (m *NetTopologyMutation) AddTopologyIDs(ids ...int) {
	if m.topology == nil {
		m.topology = make(map[int]struct{})
	}
	for i := range ids {
		m.topology[ids[i]] = struct{}{}
	}
}

// ClearTopology clears the "topology" edge to the NetTopologyDeviceMap entity.
func (m *NetTopologyMutation) ClearTopology() {
	m.clearedtopology = true
}

// TopologyCleared reports if the "topology" edge to the NetTopologyDeviceMap entity was cleared.
func (m *NetTopologyMutation) TopologyCleared() bool {
	return m.clearedtopology
}

// RemoveTopologyIDs removes the "topology" edge to the NetTopologyDeviceMap entity by IDs.
func (m *NetTopologyMutation) RemoveTopologyIDs(ids ...int) {
	if m.removedtopology == nil {
		m.removedtopology = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtopology[ids[i]] = struct{}{}
	}
}

// RemovedTopology returns the removed IDs of the "topology" edge to the NetTopologyDeviceMap entity.
func (m *NetTopologyMutation) RemovedTopologyIDs() (ids []int) {
	for id := range m.removedtopology {
		ids = append(ids, id)
	}
	return
}

// TopologyIDs returns the "topology" edge IDs in the mutation.
func (m *NetTopologyMutation) TopologyIDs() (ids []int) {
	for id := range m.topology {
		ids = append(ids, id)
	}
	return
}

// ResetTopology resets all changes to the "topology" edge.
func (m *NetTopologyMutation) ResetTopology() {
	m.topology = nil
	m.clearedtopology = false
	m.removedtopology = nil
}

// Op returns the operation name.
func (m *NetTopologyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetTopology).
func (m *NetTopologyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetTopologyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.topology_name != nil {
		fields = append(fields, nettopology.FieldTopologyName)
	}
	if m.topology_description != nil {
		fields = append(fields, nettopology.FieldTopologyDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetTopologyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nettopology.FieldTopologyName:
		return m.TopologyName()
	case nettopology.FieldTopologyDescription:
		return m.TopologyDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetTopologyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nettopology.FieldTopologyName:
		return m.OldTopologyName(ctx)
	case nettopology.FieldTopologyDescription:
		return m.OldTopologyDescription(ctx)
	}
	return nil, fmt.Errorf("unknown NetTopology field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetTopologyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nettopology.FieldTopologyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopologyName(v)
		return nil
	case nettopology.FieldTopologyDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopologyDescription(v)
		return nil
	}
	return fmt.Errorf("unknown NetTopology field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetTopologyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetTopologyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetTopologyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetTopology numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetTopologyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetTopologyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetTopologyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetTopology nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetTopologyMutation) ResetField(name string) error {
	switch name {
	case nettopology.FieldTopologyName:
		m.ResetTopologyName()
		return nil
	case nettopology.FieldTopologyDescription:
		m.ResetTopologyDescription()
		return nil
	}
	return fmt.Errorf("unknown NetTopology field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetTopologyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.topology != nil {
		edges = append(edges, nettopology.EdgeTopology)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetTopologyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nettopology.EdgeTopology:
		ids := make([]ent.Value, 0, len(m.topology))
		for id := range m.topology {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetTopologyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtopology != nil {
		edges = append(edges, nettopology.EdgeTopology)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetTopologyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nettopology.EdgeTopology:
		ids := make([]ent.Value, 0, len(m.removedtopology))
		for id := range m.removedtopology {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetTopologyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtopology {
		edges = append(edges, nettopology.EdgeTopology)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetTopologyMutation) EdgeCleared(name string) bool {
	switch name {
	case nettopology.EdgeTopology:
		return m.clearedtopology
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetTopologyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NetTopology unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetTopologyMutation) ResetEdge(name string) error {
	switch name {
	case nettopology.EdgeTopology:
		m.ResetTopology()
		return nil
	}
	return fmt.Errorf("unknown NetTopology edge %s", name)
}

// NetTopologyDeviceMapMutation represents an operation that mutates the NetTopologyDeviceMap nodes in the graph.
type NetTopologyDeviceMapMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	position_x         *int
	addposition_x      *int
	position_y         *int
	addposition_y      *int
	clearedFields      map[string]struct{}
	on_topology        *int
	clearedon_topology bool
	device             *int
	cleareddevice      bool
	edge               map[int]struct{}
	removededge        map[int]struct{}
	clearededge        bool
	done               bool
	oldValue           func(context.Context) (*NetTopologyDeviceMap, error)
	predicates         []predicate.NetTopologyDeviceMap
}

var _ ent.Mutation = (*NetTopologyDeviceMapMutation)(nil)

// nettopologydevicemapOption allows management of the mutation configuration using functional options.
type nettopologydevicemapOption func(*NetTopologyDeviceMapMutation)

// newNetTopologyDeviceMapMutation creates new mutation for the NetTopologyDeviceMap entity.
func newNetTopologyDeviceMapMutation(c config, op Op, opts ...nettopologydevicemapOption) *NetTopologyDeviceMapMutation {
	m := &NetTopologyDeviceMapMutation{
		config:        c,
		op:            op,
		typ:           TypeNetTopologyDeviceMap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetTopologyDeviceMapID sets the ID field of the mutation.
func withNetTopologyDeviceMapID(id int) nettopologydevicemapOption {
	return func(m *NetTopologyDeviceMapMutation) {
		var (
			err   error
			once  sync.Once
			value *NetTopologyDeviceMap
		)
		m.oldValue = func(ctx context.Context) (*NetTopologyDeviceMap, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetTopologyDeviceMap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetTopologyDeviceMap sets the old NetTopologyDeviceMap of the mutation.
func withNetTopologyDeviceMap(node *NetTopologyDeviceMap) nettopologydevicemapOption {
	return func(m *NetTopologyDeviceMapMutation) {
		m.oldValue = func(context.Context) (*NetTopologyDeviceMap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetTopologyDeviceMapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetTopologyDeviceMapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetTopologyDeviceMapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPositionX sets the "position_x" field.
func (m *NetTopologyDeviceMapMutation) SetPositionX(i int) {
	m.position_x = &i
	m.addposition_x = nil
}

// PositionX returns the value of the "position_x" field in the mutation.
func (m *NetTopologyDeviceMapMutation) PositionX() (r int, exists bool) {
	v := m.position_x
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionX returns the old "position_x" field's value of the NetTopologyDeviceMap entity.
// If the NetTopologyDeviceMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetTopologyDeviceMapMutation) OldPositionX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionX: %w", err)
	}
	return oldValue.PositionX, nil
}

// AddPositionX adds i to the "position_x" field.
func (m *NetTopologyDeviceMapMutation) AddPositionX(i int) {
	if m.addposition_x != nil {
		*m.addposition_x += i
	} else {
		m.addposition_x = &i
	}
}

// AddedPositionX returns the value that was added to the "position_x" field in this mutation.
func (m *NetTopologyDeviceMapMutation) AddedPositionX() (r int, exists bool) {
	v := m.addposition_x
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionX resets all changes to the "position_x" field.
func (m *NetTopologyDeviceMapMutation) ResetPositionX() {
	m.position_x = nil
	m.addposition_x = nil
}

// SetPositionY sets the "position_y" field.
func (m *NetTopologyDeviceMapMutation) SetPositionY(i int) {
	m.position_y = &i
	m.addposition_y = nil
}

// PositionY returns the value of the "position_y" field in the mutation.
func (m *NetTopologyDeviceMapMutation) PositionY() (r int, exists bool) {
	v := m.position_y
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionY returns the old "position_y" field's value of the NetTopologyDeviceMap entity.
// If the NetTopologyDeviceMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetTopologyDeviceMapMutation) OldPositionY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionY: %w", err)
	}
	return oldValue.PositionY, nil
}

// AddPositionY adds i to the "position_y" field.
func (m *NetTopologyDeviceMapMutation) AddPositionY(i int) {
	if m.addposition_y != nil {
		*m.addposition_y += i
	} else {
		m.addposition_y = &i
	}
}

// AddedPositionY returns the value that was added to the "position_y" field in this mutation.
func (m *NetTopologyDeviceMapMutation) AddedPositionY() (r int, exists bool) {
	v := m.addposition_y
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionY resets all changes to the "position_y" field.
func (m *NetTopologyDeviceMapMutation) ResetPositionY() {
	m.position_y = nil
	m.addposition_y = nil
}

// SetOnTopologyID sets the "on_topology" edge to the NetTopology entity by id.
func (m *NetTopologyDeviceMapMutation) SetOnTopologyID(id int) {
	m.on_topology = &id
}

// ClearOnTopology clears the "on_topology" edge to the NetTopology entity.
func (m *NetTopologyDeviceMapMutation) ClearOnTopology() {
	m.clearedon_topology = true
}

// OnTopologyCleared reports if the "on_topology" edge to the NetTopology entity was cleared.
func (m *NetTopologyDeviceMapMutation) OnTopologyCleared() bool {
	return m.clearedon_topology
}

// OnTopologyID returns the "on_topology" edge ID in the mutation.
func (m *NetTopologyDeviceMapMutation) OnTopologyID() (id int, exists bool) {
	if m.on_topology != nil {
		return *m.on_topology, true
	}
	return
}

// OnTopologyIDs returns the "on_topology" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OnTopologyID instead. It exists only for internal usage by the builders.
func (m *NetTopologyDeviceMapMutation) OnTopologyIDs() (ids []int) {
	if id := m.on_topology; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOnTopology resets all changes to the "on_topology" edge.
func (m *NetTopologyDeviceMapMutation) ResetOnTopology() {
	m.on_topology = nil
	m.clearedon_topology = false
}

// SetDeviceID sets the "device" edge to the Device entity by id.
func (m *NetTopologyDeviceMapMutation) SetDeviceID(id int) {
	m.device = &id
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *NetTopologyDeviceMapMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *NetTopologyDeviceMapMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the "device" edge ID in the mutation.
func (m *NetTopologyDeviceMapMutation) DeviceID() (id int, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *NetTopologyDeviceMapMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *NetTopologyDeviceMapMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddEdgeIDs adds the "edge" edge to the NetTopologyDeviceMap entity by ids.
func (m *NetTopologyDeviceMapMutation) AddEdgeIDs(ids ...int) {
	if m.edge == nil {
		m.edge = make(map[int]struct{})
	}
	for i := range ids {
		m.edge[ids[i]] = struct{}{}
	}
}

// ClearEdgeEdge clears the "edge" edge to the NetTopologyDeviceMap entity.
func (m *NetTopologyDeviceMapMutation) ClearEdgeEdge() {
	m.clearededge = true
}

// EdgeEdgeCleared reports if the "edge" edge to the NetTopologyDeviceMap entity was cleared.
func (m *NetTopologyDeviceMapMutation) EdgeEdgeCleared() bool {
	return m.clearededge
}

// RemoveEdgeIDs removes the "edge" edge to the NetTopologyDeviceMap entity by IDs.
func (m *NetTopologyDeviceMapMutation) RemoveEdgeIDs(ids ...int) {
	if m.removededge == nil {
		m.removededge = make(map[int]struct{})
	}
	for i := range ids {
		m.removededge[ids[i]] = struct{}{}
	}
}

// RemovedEdge returns the removed IDs of the "edge" edge to the NetTopologyDeviceMap entity.
func (m *NetTopologyDeviceMapMutation) RemovedEdgeIDs() (ids []int) {
	for id := range m.removededge {
		ids = append(ids, id)
	}
	return
}

// EdgeIDs returns the "edge" edge IDs in the mutation.
func (m *NetTopologyDeviceMapMutation) EdgeIDs() (ids []int) {
	for id := range m.edge {
		ids = append(ids, id)
	}
	return
}

// ResetEdgeEdge resets all changes to the "edge" edge.
func (m *NetTopologyDeviceMapMutation) ResetEdgeEdge() {
	m.edge = nil
	m.clearededge = false
	m.removededge = nil
}

// Op returns the operation name.
func (m *NetTopologyDeviceMapMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetTopologyDeviceMap).
func (m *NetTopologyDeviceMapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetTopologyDeviceMapMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.position_x != nil {
		fields = append(fields, nettopologydevicemap.FieldPositionX)
	}
	if m.position_y != nil {
		fields = append(fields, nettopologydevicemap.FieldPositionY)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetTopologyDeviceMapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		return m.PositionX()
	case nettopologydevicemap.FieldPositionY:
		return m.PositionY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetTopologyDeviceMapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		return m.OldPositionX(ctx)
	case nettopologydevicemap.FieldPositionY:
		return m.OldPositionY(ctx)
	}
	return nil, fmt.Errorf("unknown NetTopologyDeviceMap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetTopologyDeviceMapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionX(v)
		return nil
	case nettopologydevicemap.FieldPositionY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionY(v)
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetTopologyDeviceMapMutation) AddedFields() []string {
	var fields []string
	if m.addposition_x != nil {
		fields = append(fields, nettopologydevicemap.FieldPositionX)
	}
	if m.addposition_y != nil {
		fields = append(fields, nettopologydevicemap.FieldPositionY)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetTopologyDeviceMapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		return m.AddedPositionX()
	case nettopologydevicemap.FieldPositionY:
		return m.AddedPositionY()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetTopologyDeviceMapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionX(v)
		return nil
	case nettopologydevicemap.FieldPositionY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionY(v)
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetTopologyDeviceMapMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetTopologyDeviceMapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetTopologyDeviceMapMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetTopologyDeviceMap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetTopologyDeviceMapMutation) ResetField(name string) error {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		m.ResetPositionX()
		return nil
	case nettopologydevicemap.FieldPositionY:
		m.ResetPositionY()
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetTopologyDeviceMapMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.on_topology != nil {
		edges = append(edges, nettopologydevicemap.EdgeOnTopology)
	}
	if m.device != nil {
		edges = append(edges, nettopologydevicemap.EdgeDevice)
	}
	if m.edge != nil {
		edges = append(edges, nettopologydevicemap.EdgeEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetTopologyDeviceMapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nettopologydevicemap.EdgeOnTopology:
		if id := m.on_topology; id != nil {
			return []ent.Value{*id}
		}
	case nettopologydevicemap.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case nettopologydevicemap.EdgeEdge:
		ids := make([]ent.Value, 0, len(m.edge))
		for id := range m.edge {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetTopologyDeviceMapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removededge != nil {
		edges = append(edges, nettopologydevicemap.EdgeEdge)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetTopologyDeviceMapMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nettopologydevicemap.EdgeEdge:
		ids := make([]ent.Value, 0, len(m.removededge))
		for id := range m.removededge {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetTopologyDeviceMapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedon_topology {
		edges = append(edges, nettopologydevicemap.EdgeOnTopology)
	}
	if m.cleareddevice {
		edges = append(edges, nettopologydevicemap.EdgeDevice)
	}
	if m.clearededge {
		edges = append(edges, nettopologydevicemap.EdgeEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetTopologyDeviceMapMutation) EdgeCleared(name string) bool {
	switch name {
	case nettopologydevicemap.EdgeOnTopology:
		return m.clearedon_topology
	case nettopologydevicemap.EdgeDevice:
		return m.cleareddevice
	case nettopologydevicemap.EdgeEdge:
		return m.clearededge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetTopologyDeviceMapMutation) ClearEdge(name string) error {
	switch name {
	case nettopologydevicemap.EdgeOnTopology:
		m.ClearOnTopology()
		return nil
	case nettopologydevicemap.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetTopologyDeviceMapMutation) ResetEdge(name string) error {
	switch name {
	case nettopologydevicemap.EdgeOnTopology:
		m.ResetOnTopology()
		return nil
	case nettopologydevicemap.EdgeDevice:
		m.ResetDevice()
		return nil
	case nettopologydevicemap.EdgeEdge:
		m.ResetEdgeEdge()
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap edge %s", name)
}

// PortChannelInterfaceMutation represents an operation that mutates the PortChannelInterface nodes in the graph.
type PortChannelInterfaceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	po_interface_id       *int
	addpo_interface_id    *int
	po_interface_shutdown *bool
	clearedFields         map[string]struct{}
	mode                  *int
	clearedmode           bool
	have_vlans            map[int]struct{}
	removedhave_vlans     map[int]struct{}
	clearedhave_vlans     bool
	native_on_vlan        *int
	clearednative_on_vlan bool
	on_device             *int
	clearedon_device      bool
	interfaces            map[int]struct{}
	removedinterfaces     map[int]struct{}
	clearedinterfaces     bool
	done                  bool
	oldValue              func(context.Context) (*PortChannelInterface, error)
	predicates            []predicate.PortChannelInterface
}

var _ ent.Mutation = (*PortChannelInterfaceMutation)(nil)

// portchannelinterfaceOption allows management of the mutation configuration using functional options.
type portchannelinterfaceOption func(*PortChannelInterfaceMutation)

// newPortChannelInterfaceMutation creates new mutation for the PortChannelInterface entity.
func newPortChannelInterfaceMutation(c config, op Op, opts ...portchannelinterfaceOption) *PortChannelInterfaceMutation {
	m := &PortChannelInterfaceMutation{
		config:        c,
		op:            op,
		typ:           TypePortChannelInterface,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortChannelInterfaceID sets the ID field of the mutation.
func withPortChannelInterfaceID(id int) portchannelinterfaceOption {
	return func(m *PortChannelInterfaceMutation) {
		var (
			err   error
			once  sync.Once
			value *PortChannelInterface
		)
		m.oldValue = func(ctx context.Context) (*PortChannelInterface, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PortChannelInterface.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortChannelInterface sets the old PortChannelInterface of the mutation.
func withPortChannelInterface(node *PortChannelInterface) portchannelinterfaceOption {
	return func(m *PortChannelInterfaceMutation) {
		m.oldValue = func(context.Context) (*PortChannelInterface, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortChannelInterfaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortChannelInterfaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PortChannelInterfaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPoInterfaceID sets the "po_interface_id" field.
func (m *PortChannelInterfaceMutation) SetPoInterfaceID(i int) {
	m.po_interface_id = &i
	m.addpo_interface_id = nil
}

// PoInterfaceID returns the value of the "po_interface_id" field in the mutation.
func (m *PortChannelInterfaceMutation) PoInterfaceID() (r int, exists bool) {
	v := m.po_interface_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPoInterfaceID returns the old "po_interface_id" field's value of the PortChannelInterface entity.
// If the PortChannelInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortChannelInterfaceMutation) OldPoInterfaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoInterfaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoInterfaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoInterfaceID: %w", err)
	}
	return oldValue.PoInterfaceID, nil
}

// AddPoInterfaceID adds i to the "po_interface_id" field.
func (m *PortChannelInterfaceMutation) AddPoInterfaceID(i int) {
	if m.addpo_interface_id != nil {
		*m.addpo_interface_id += i
	} else {
		m.addpo_interface_id = &i
	}
}

// AddedPoInterfaceID returns the value that was added to the "po_interface_id" field in this mutation.
func (m *PortChannelInterfaceMutation) AddedPoInterfaceID() (r int, exists bool) {
	v := m.addpo_interface_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoInterfaceID resets all changes to the "po_interface_id" field.
func (m *PortChannelInterfaceMutation) ResetPoInterfaceID() {
	m.po_interface_id = nil
	m.addpo_interface_id = nil
}

// SetPoInterfaceShutdown sets the "po_interface_shutdown" field.
func (m *PortChannelInterfaceMutation) SetPoInterfaceShutdown(b bool) {
	m.po_interface_shutdown = &b
}

// PoInterfaceShutdown returns the value of the "po_interface_shutdown" field in the mutation.
func (m *PortChannelInterfaceMutation) PoInterfaceShutdown() (r bool, exists bool) {
	v := m.po_interface_shutdown
	if v == nil {
		return
	}
	return *v, true
}

// OldPoInterfaceShutdown returns the old "po_interface_shutdown" field's value of the PortChannelInterface entity.
// If the PortChannelInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortChannelInterfaceMutation) OldPoInterfaceShutdown(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoInterfaceShutdown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoInterfaceShutdown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoInterfaceShutdown: %w", err)
	}
	return oldValue.PoInterfaceShutdown, nil
}

// ResetPoInterfaceShutdown resets all changes to the "po_interface_shutdown" field.
func (m *PortChannelInterfaceMutation) ResetPoInterfaceShutdown() {
	m.po_interface_shutdown = nil
}

// SetModeID sets the "mode" edge to the NetInterfaceMode entity by id.
func (m *PortChannelInterfaceMutation) SetModeID(id int) {
	m.mode = &id
}

// ClearMode clears the "mode" edge to the NetInterfaceMode entity.
func (m *PortChannelInterfaceMutation) ClearMode() {
	m.clearedmode = true
}

// ModeCleared reports if the "mode" edge to the NetInterfaceMode entity was cleared.
func (m *PortChannelInterfaceMutation) ModeCleared() bool {
	return m.clearedmode
}

// ModeID returns the "mode" edge ID in the mutation.
func (m *PortChannelInterfaceMutation) ModeID() (id int, exists bool) {
	if m.mode != nil {
		return *m.mode, true
	}
	return
}

// ModeIDs returns the "mode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModeID instead. It exists only for internal usage by the builders.
func (m *PortChannelInterfaceMutation) ModeIDs() (ids []int) {
	if id := m.mode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMode resets all changes to the "mode" edge.
func (m *PortChannelInterfaceMutation) ResetMode() {
	m.mode = nil
	m.clearedmode = false
}

// AddHaveVlanIDs adds the "have_vlans" edge to the Vlan entity by ids.
func (m *PortChannelInterfaceMutation) AddHaveVlanIDs(ids ...int) {
	if m.have_vlans == nil {
		m.have_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.have_vlans[ids[i]] = struct{}{}
	}
}

// ClearHaveVlans clears the "have_vlans" edge to the Vlan entity.
func (m *PortChannelInterfaceMutation) ClearHaveVlans() {
	m.clearedhave_vlans = true
}

// HaveVlansCleared reports if the "have_vlans" edge to the Vlan entity was cleared.
func (m *PortChannelInterfaceMutation) HaveVlansCleared() bool {
	return m.clearedhave_vlans
}

// RemoveHaveVlanIDs removes the "have_vlans" edge to the Vlan entity by IDs.
func (m *PortChannelInterfaceMutation) RemoveHaveVlanIDs(ids ...int) {
	if m.removedhave_vlans == nil {
		m.removedhave_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhave_vlans[ids[i]] = struct{}{}
	}
}

// RemovedHaveVlans returns the removed IDs of the "have_vlans" edge to the Vlan entity.
func (m *PortChannelInterfaceMutation) RemovedHaveVlansIDs() (ids []int) {
	for id := range m.removedhave_vlans {
		ids = append(ids, id)
	}
	return
}

// HaveVlansIDs returns the "have_vlans" edge IDs in the mutation.
func (m *PortChannelInterfaceMutation) HaveVlansIDs() (ids []int) {
	for id := range m.have_vlans {
		ids = append(ids, id)
	}
	return
}

// ResetHaveVlans resets all changes to the "have_vlans" edge.
func (m *PortChannelInterfaceMutation) ResetHaveVlans() {
	m.have_vlans = nil
	m.clearedhave_vlans = false
	m.removedhave_vlans = nil
}

// SetNativeOnVlanID sets the "native_on_vlan" edge to the Vlan entity by id.
func (m *PortChannelInterfaceMutation) SetNativeOnVlanID(id int) {
	m.native_on_vlan = &id
}

// ClearNativeOnVlan clears the "native_on_vlan" edge to the Vlan entity.
func (m *PortChannelInterfaceMutation) ClearNativeOnVlan() {
	m.clearednative_on_vlan = true
}

// NativeOnVlanCleared reports if the "native_on_vlan" edge to the Vlan entity was cleared.
func (m *PortChannelInterfaceMutation) NativeOnVlanCleared() bool {
	return m.clearednative_on_vlan
}

// NativeOnVlanID returns the "native_on_vlan" edge ID in the mutation.
func (m *PortChannelInterfaceMutation) NativeOnVlanID() (id int, exists bool) {
	if m.native_on_vlan != nil {
		return *m.native_on_vlan, true
	}
	return
}

// NativeOnVlanIDs returns the "native_on_vlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NativeOnVlanID instead. It exists only for internal usage by the builders.
func (m *PortChannelInterfaceMutation) NativeOnVlanIDs() (ids []int) {
	if id := m.native_on_vlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNativeOnVlan resets all changes to the "native_on_vlan" edge.
func (m *PortChannelInterfaceMutation) ResetNativeOnVlan() {
	m.native_on_vlan = nil
	m.clearednative_on_vlan = false
}

// SetOnDeviceID sets the "on_device" edge to the Device entity by id.
func (m *PortChannelInterfaceMutation) SetOnDeviceID(id int) {
	m.on_device = &id
}

// ClearOnDevice clears the "on_device" edge to the Device entity.
func (m *PortChannelInterfaceMutation) ClearOnDevice() {
	m.clearedon_device = true
}

// OnDeviceCleared reports if the "on_device" edge to the Device entity was cleared.
func (m *PortChannelInterfaceMutation) OnDeviceCleared() bool {
	return m.clearedon_device
}

// OnDeviceID returns the "on_device" edge ID in the mutation.
func (m *PortChannelInterfaceMutation) OnDeviceID() (id int, exists bool) {
	if m.on_device != nil {
		return *m.on_device, true
	}
	return
}

// OnDeviceIDs returns the "on_device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OnDeviceID instead. It exists only for internal usage by the builders.
func (m *PortChannelInterfaceMutation) OnDeviceIDs() (ids []int) {
	if id := m.on_device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOnDevice resets all changes to the "on_device" edge.
func (m *PortChannelInterfaceMutation) ResetOnDevice() {
	m.on_device = nil
	m.clearedon_device = false
}

// AddInterfaceIDs adds the "interfaces" edge to the NetInterface entity by ids.
func (m *PortChannelInterfaceMutation) AddInterfaceIDs(ids ...int) {
	if m.interfaces == nil {
		m.interfaces = make(map[int]struct{})
	}
	for i := range ids {
		m.interfaces[ids[i]] = struct{}{}
	}
}

// ClearInterfaces clears the "interfaces" edge to the NetInterface entity.
func (m *PortChannelInterfaceMutation) ClearInterfaces() {
	m.clearedinterfaces = true
}

// InterfacesCleared reports if the "interfaces" edge to the NetInterface entity was cleared.
func (m *PortChannelInterfaceMutation) InterfacesCleared() bool {
	return m.clearedinterfaces
}

// RemoveInterfaceIDs removes the "interfaces" edge to the NetInterface entity by IDs.
func (m *PortChannelInterfaceMutation) RemoveInterfaceIDs(ids ...int) {
	if m.removedinterfaces == nil {
		m.removedinterfaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinterfaces[ids[i]] = struct{}{}
	}
}

// RemovedInterfaces returns the removed IDs of the "interfaces" edge to the NetInterface entity.
func (m *PortChannelInterfaceMutation) RemovedInterfacesIDs() (ids []int) {
	for id := range m.removedinterfaces {
		ids = append(ids, id)
	}
	return
}

// InterfacesIDs returns the "interfaces" edge IDs in the mutation.
func (m *PortChannelInterfaceMutation) InterfacesIDs() (ids []int) {
	for id := range m.interfaces {
		ids = append(ids, id)
	}
	return
}

// ResetInterfaces resets all changes to the "interfaces" edge.
func (m *PortChannelInterfaceMutation) ResetInterfaces() {
	m.interfaces = nil
	m.clearedinterfaces = false
	m.removedinterfaces = nil
}

// Op returns the operation name.
func (m *PortChannelInterfaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PortChannelInterface).
func (m *PortChannelInterfaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortChannelInterfaceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.po_interface_id != nil {
		fields = append(fields, portchannelinterface.FieldPoInterfaceID)
	}
	if m.po_interface_shutdown != nil {
		fields = append(fields, portchannelinterface.FieldPoInterfaceShutdown)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortChannelInterfaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portchannelinterface.FieldPoInterfaceID:
		return m.PoInterfaceID()
	case portchannelinterface.FieldPoInterfaceShutdown:
		return m.PoInterfaceShutdown()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortChannelInterfaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portchannelinterface.FieldPoInterfaceID:
		return m.OldPoInterfaceID(ctx)
	case portchannelinterface.FieldPoInterfaceShutdown:
		return m.OldPoInterfaceShutdown(ctx)
	}
	return nil, fmt.Errorf("unknown PortChannelInterface field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortChannelInterfaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portchannelinterface.FieldPoInterfaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoInterfaceID(v)
		return nil
	case portchannelinterface.FieldPoInterfaceShutdown:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoInterfaceShutdown(v)
		return nil
	}
	return fmt.Errorf("unknown PortChannelInterface field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortChannelInterfaceMutation) AddedFields() []string {
	var fields []string
	if m.addpo_interface_id != nil {
		fields = append(fields, portchannelinterface.FieldPoInterfaceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortChannelInterfaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case portchannelinterface.FieldPoInterfaceID:
		return m.AddedPoInterfaceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortChannelInterfaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case portchannelinterface.FieldPoInterfaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoInterfaceID(v)
		return nil
	}
	return fmt.Errorf("unknown PortChannelInterface numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortChannelInterfaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortChannelInterfaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortChannelInterfaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PortChannelInterface nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortChannelInterfaceMutation) ResetField(name string) error {
	switch name {
	case portchannelinterface.FieldPoInterfaceID:
		m.ResetPoInterfaceID()
		return nil
	case portchannelinterface.FieldPoInterfaceShutdown:
		m.ResetPoInterfaceShutdown()
		return nil
	}
	return fmt.Errorf("unknown PortChannelInterface field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortChannelInterfaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.mode != nil {
		edges = append(edges, portchannelinterface.EdgeMode)
	}
	if m.have_vlans != nil {
		edges = append(edges, portchannelinterface.EdgeHaveVlans)
	}
	if m.native_on_vlan != nil {
		edges = append(edges, portchannelinterface.EdgeNativeOnVlan)
	}
	if m.on_device != nil {
		edges = append(edges, portchannelinterface.EdgeOnDevice)
	}
	if m.interfaces != nil {
		edges = append(edges, portchannelinterface.EdgeInterfaces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortChannelInterfaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portchannelinterface.EdgeMode:
		if id := m.mode; id != nil {
			return []ent.Value{*id}
		}
	case portchannelinterface.EdgeHaveVlans:
		ids := make([]ent.Value, 0, len(m.have_vlans))
		for id := range m.have_vlans {
			ids = append(ids, id)
		}
		return ids
	case portchannelinterface.EdgeNativeOnVlan:
		if id := m.native_on_vlan; id != nil {
			return []ent.Value{*id}
		}
	case portchannelinterface.EdgeOnDevice:
		if id := m.on_device; id != nil {
			return []ent.Value{*id}
		}
	case portchannelinterface.EdgeInterfaces:
		ids := make([]ent.Value, 0, len(m.interfaces))
		for id := range m.interfaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortChannelInterfaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedhave_vlans != nil {
		edges = append(edges, portchannelinterface.EdgeHaveVlans)
	}
	if m.removedinterfaces != nil {
		edges = append(edges, portchannelinterface.EdgeInterfaces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortChannelInterfaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case portchannelinterface.EdgeHaveVlans:
		ids := make([]ent.Value, 0, len(m.removedhave_vlans))
		for id := range m.removedhave_vlans {
			ids = append(ids, id)
		}
		return ids
	case portchannelinterface.EdgeInterfaces:
		ids := make([]ent.Value, 0, len(m.removedinterfaces))
		for id := range m.removedinterfaces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortChannelInterfaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedmode {
		edges = append(edges, portchannelinterface.EdgeMode)
	}
	if m.clearedhave_vlans {
		edges = append(edges, portchannelinterface.EdgeHaveVlans)
	}
	if m.clearednative_on_vlan {
		edges = append(edges, portchannelinterface.EdgeNativeOnVlan)
	}
	if m.clearedon_device {
		edges = append(edges, portchannelinterface.EdgeOnDevice)
	}
	if m.clearedinterfaces {
		edges = append(edges, portchannelinterface.EdgeInterfaces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortChannelInterfaceMutation) EdgeCleared(name string) bool {
	switch name {
	case portchannelinterface.EdgeMode:
		return m.clearedmode
	case portchannelinterface.EdgeHaveVlans:
		return m.clearedhave_vlans
	case portchannelinterface.EdgeNativeOnVlan:
		return m.clearednative_on_vlan
	case portchannelinterface.EdgeOnDevice:
		return m.clearedon_device
	case portchannelinterface.EdgeInterfaces:
		return m.clearedinterfaces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortChannelInterfaceMutation) ClearEdge(name string) error {
	switch name {
	case portchannelinterface.EdgeMode:
		m.ClearMode()
		return nil
	case portchannelinterface.EdgeNativeOnVlan:
		m.ClearNativeOnVlan()
		return nil
	case portchannelinterface.EdgeOnDevice:
		m.ClearOnDevice()
		return nil
	}
	return fmt.Errorf("unknown PortChannelInterface unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortChannelInterfaceMutation) ResetEdge(name string) error {
	switch name {
	case portchannelinterface.EdgeMode:
		m.ResetMode()
		return nil
	case portchannelinterface.EdgeHaveVlans:
		m.ResetHaveVlans()
		return nil
	case portchannelinterface.EdgeNativeOnVlan:
		m.ResetNativeOnVlan()
		return nil
	case portchannelinterface.EdgeOnDevice:
		m.ResetOnDevice()
		return nil
	case portchannelinterface.EdgeInterfaces:
		m.ResetInterfaces()
		return nil
	}
	return fmt.Errorf("unknown PortChannelInterface edge %s", name)
}

// VlanMutation represents an operation that mutates the Vlan nodes in the graph.
type VlanMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	vlan_id               *int
	addvlan_id            *int
	clearedFields         map[string]struct{}
	vlans                 map[int]struct{}
	removedvlans          map[int]struct{}
	clearedvlans          bool
	native_vlan           map[int]struct{}
	removednative_vlan    map[int]struct{}
	clearednative_vlan    bool
	po_vlans              map[int]struct{}
	removedpo_vlans       map[int]struct{}
	clearedpo_vlans       bool
	po_native_vlan        map[int]struct{}
	removedpo_native_vlan map[int]struct{}
	clearedpo_native_vlan bool
	on_device             map[int]struct{}
	removedon_device      map[int]struct{}
	clearedon_device      bool
	done                  bool
	oldValue              func(context.Context) (*Vlan, error)
	predicates            []predicate.Vlan
}

var _ ent.Mutation = (*VlanMutation)(nil)

// vlanOption allows management of the mutation configuration using functional options.
type vlanOption func(*VlanMutation)

// newVlanMutation creates new mutation for the Vlan entity.
func newVlanMutation(c config, op Op, opts ...vlanOption) *VlanMutation {
	m := &VlanMutation{
		config:        c,
		op:            op,
		typ:           TypeVlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVlanID sets the ID field of the mutation.
func withVlanID(id int) vlanOption {
	return func(m *VlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Vlan
		)
		m.oldValue = func(ctx context.Context) (*Vlan, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVlan sets the old Vlan of the mutation.
func withVlan(node *Vlan) vlanOption {
	return func(m *VlanMutation) {
		m.oldValue = func(context.Context) (*Vlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *VlanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetVlanID sets the "vlan_id" field.
func (m *VlanMutation) SetVlanID(i int) {
	m.vlan_id = &i
	m.addvlan_id = nil
}

// VlanID returns the value of the "vlan_id" field in the mutation.
func (m *VlanMutation) VlanID() (r int, exists bool) {
	v := m.vlan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVlanID returns the old "vlan_id" field's value of the Vlan entity.
// If the Vlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VlanMutation) OldVlanID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVlanID: %w", err)
	}
	return oldValue.VlanID, nil
}

// AddVlanID adds i to the "vlan_id" field.
func (m *VlanMutation) AddVlanID(i int) {
	if m.addvlan_id != nil {
		*m.addvlan_id += i
	} else {
		m.addvlan_id = &i
	}
}

// AddedVlanID returns the value that was added to the "vlan_id" field in this mutation.
func (m *VlanMutation) AddedVlanID() (r int, exists bool) {
	v := m.addvlan_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetVlanID resets all changes to the "vlan_id" field.
func (m *VlanMutation) ResetVlanID() {
	m.vlan_id = nil
	m.addvlan_id = nil
}

// AddVlanIDs adds the "vlans" edge to the NetInterface entity by ids.
func (m *VlanMutation) AddVlanIDs(ids ...int) {
	if m.vlans == nil {
		m.vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.vlans[ids[i]] = struct{}{}
	}
}

// ClearVlans clears the "vlans" edge to the NetInterface entity.
func (m *VlanMutation) ClearVlans() {
	m.clearedvlans = true
}

// VlansCleared reports if the "vlans" edge to the NetInterface entity was cleared.
func (m *VlanMutation) VlansCleared() bool {
	return m.clearedvlans
}

// RemoveVlanIDs removes the "vlans" edge to the NetInterface entity by IDs.
func (m *VlanMutation) RemoveVlanIDs(ids ...int) {
	if m.removedvlans == nil {
		m.removedvlans = make(map[int]struct{})
	}
	for i := range ids {
		m.removedvlans[ids[i]] = struct{}{}
	}
}

// RemovedVlans returns the removed IDs of the "vlans" edge to the NetInterface entity.
func (m *VlanMutation) RemovedVlansIDs() (ids []int) {
	for id := range m.removedvlans {
		ids = append(ids, id)
	}
	return
}

// VlansIDs returns the "vlans" edge IDs in the mutation.
func (m *VlanMutation) VlansIDs() (ids []int) {
	for id := range m.vlans {
		ids = append(ids, id)
	}
	return
}

// ResetVlans resets all changes to the "vlans" edge.
func (m *VlanMutation) ResetVlans() {
	m.vlans = nil
	m.clearedvlans = false
	m.removedvlans = nil
}

// AddNativeVlanIDs adds the "native_vlan" edge to the NetInterface entity by ids.
func (m *VlanMutation) AddNativeVlanIDs(ids ...int) {
	if m.native_vlan == nil {
		m.native_vlan = make(map[int]struct{})
	}
	for i := range ids {
		m.native_vlan[ids[i]] = struct{}{}
	}
}

// ClearNativeVlan clears the "native_vlan" edge to the NetInterface entity.
func (m *VlanMutation) ClearNativeVlan() {
	m.clearednative_vlan = true
}

// NativeVlanCleared reports if the "native_vlan" edge to the NetInterface entity was cleared.
func (m *VlanMutation) NativeVlanCleared() bool {
	return m.clearednative_vlan
}

// RemoveNativeVlanIDs removes the "native_vlan" edge to the NetInterface entity by IDs.
func (m *VlanMutation) RemoveNativeVlanIDs(ids ...int) {
	if m.removednative_vlan == nil {
		m.removednative_vlan = make(map[int]struct{})
	}
	for i := range ids {
		m.removednative_vlan[ids[i]] = struct{}{}
	}
}

// RemovedNativeVlan returns the removed IDs of the "native_vlan" edge to the NetInterface entity.
func (m *VlanMutation) RemovedNativeVlanIDs() (ids []int) {
	for id := range m.removednative_vlan {
		ids = append(ids, id)
	}
	return
}

// NativeVlanIDs returns the "native_vlan" edge IDs in the mutation.
func (m *VlanMutation) NativeVlanIDs() (ids []int) {
	for id := range m.native_vlan {
		ids = append(ids, id)
	}
	return
}

// ResetNativeVlan resets all changes to the "native_vlan" edge.
func (m *VlanMutation) ResetNativeVlan() {
	m.native_vlan = nil
	m.clearednative_vlan = false
	m.removednative_vlan = nil
}

// AddPoVlanIDs adds the "po_vlans" edge to the PortChannelInterface entity by ids.
func (m *VlanMutation) AddPoVlanIDs(ids ...int) {
	if m.po_vlans == nil {
		m.po_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.po_vlans[ids[i]] = struct{}{}
	}
}

// ClearPoVlans clears the "po_vlans" edge to the PortChannelInterface entity.
func (m *VlanMutation) ClearPoVlans() {
	m.clearedpo_vlans = true
}

// PoVlansCleared reports if the "po_vlans" edge to the PortChannelInterface entity was cleared.
func (m *VlanMutation) PoVlansCleared() bool {
	return m.clearedpo_vlans
}

// RemovePoVlanIDs removes the "po_vlans" edge to the PortChannelInterface entity by IDs.
func (m *VlanMutation) RemovePoVlanIDs(ids ...int) {
	if m.removedpo_vlans == nil {
		m.removedpo_vlans = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpo_vlans[ids[i]] = struct{}{}
	}
}

// RemovedPoVlans returns the removed IDs of the "po_vlans" edge to the PortChannelInterface entity.
func (m *VlanMutation) RemovedPoVlansIDs() (ids []int) {
	for id := range m.removedpo_vlans {
		ids = append(ids, id)
	}
	return
}

// PoVlansIDs returns the "po_vlans" edge IDs in the mutation.
func (m *VlanMutation) PoVlansIDs() (ids []int) {
	for id := range m.po_vlans {
		ids = append(ids, id)
	}
	return
}

// ResetPoVlans resets all changes to the "po_vlans" edge.
func (m *VlanMutation) ResetPoVlans() {
	m.po_vlans = nil
	m.clearedpo_vlans = false
	m.removedpo_vlans = nil
}

// AddPoNativeVlanIDs adds the "po_native_vlan" edge to the PortChannelInterface entity by ids.
func (m *VlanMutation) AddPoNativeVlanIDs(ids ...int) {
	if m.po_native_vlan == nil {
		m.po_native_vlan = make(map[int]struct{})
	}
	for i := range ids {
		m.po_native_vlan[ids[i]] = struct{}{}
	}
}

// ClearPoNativeVlan clears the "po_native_vlan" edge to the PortChannelInterface entity.
func (m *VlanMutation) ClearPoNativeVlan() {
	m.clearedpo_native_vlan = true
}

// PoNativeVlanCleared reports if the "po_native_vlan" edge to the PortChannelInterface entity was cleared.
func (m *VlanMutation) PoNativeVlanCleared() bool {
	return m.clearedpo_native_vlan
}

// RemovePoNativeVlanIDs removes the "po_native_vlan" edge to the PortChannelInterface entity by IDs.
func (m *VlanMutation) RemovePoNativeVlanIDs(ids ...int) {
	if m.removedpo_native_vlan == nil {
		m.removedpo_native_vlan = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpo_native_vlan[ids[i]] = struct{}{}
	}
}

// RemovedPoNativeVlan returns the removed IDs of the "po_native_vlan" edge to the PortChannelInterface entity.
func (m *VlanMutation) RemovedPoNativeVlanIDs() (ids []int) {
	for id := range m.removedpo_native_vlan {
		ids = append(ids, id)
	}
	return
}

// PoNativeVlanIDs returns the "po_native_vlan" edge IDs in the mutation.
func (m *VlanMutation) PoNativeVlanIDs() (ids []int) {
	for id := range m.po_native_vlan {
		ids = append(ids, id)
	}
	return
}

// ResetPoNativeVlan resets all changes to the "po_native_vlan" edge.
func (m *VlanMutation) ResetPoNativeVlan() {
	m.po_native_vlan = nil
	m.clearedpo_native_vlan = false
	m.removedpo_native_vlan = nil
}

// AddOnDeviceIDs adds the "on_device" edge to the Device entity by ids.
func (m *VlanMutation) AddOnDeviceIDs(ids ...int) {
	if m.on_device == nil {
		m.on_device = make(map[int]struct{})
	}
	for i := range ids {
		m.on_device[ids[i]] = struct{}{}
	}
}

// ClearOnDevice clears the "on_device" edge to the Device entity.
func (m *VlanMutation) ClearOnDevice() {
	m.clearedon_device = true
}

// OnDeviceCleared reports if the "on_device" edge to the Device entity was cleared.
func (m *VlanMutation) OnDeviceCleared() bool {
	return m.clearedon_device
}

// RemoveOnDeviceIDs removes the "on_device" edge to the Device entity by IDs.
func (m *VlanMutation) RemoveOnDeviceIDs(ids ...int) {
	if m.removedon_device == nil {
		m.removedon_device = make(map[int]struct{})
	}
	for i := range ids {
		m.removedon_device[ids[i]] = struct{}{}
	}
}

// RemovedOnDevice returns the removed IDs of the "on_device" edge to the Device entity.
func (m *VlanMutation) RemovedOnDeviceIDs() (ids []int) {
	for id := range m.removedon_device {
		ids = append(ids, id)
	}
	return
}

// OnDeviceIDs returns the "on_device" edge IDs in the mutation.
func (m *VlanMutation) OnDeviceIDs() (ids []int) {
	for id := range m.on_device {
		ids = append(ids, id)
	}
	return
}

// ResetOnDevice resets all changes to the "on_device" edge.
func (m *VlanMutation) ResetOnDevice() {
	m.on_device = nil
	m.clearedon_device = false
	m.removedon_device = nil
}

// Op returns the operation name.
func (m *VlanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vlan).
func (m *VlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VlanMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.vlan_id != nil {
		fields = append(fields, vlan.FieldVlanID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vlan.FieldVlanID:
		return m.VlanID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vlan.FieldVlanID:
		return m.OldVlanID(ctx)
	}
	return nil, fmt.Errorf("unknown Vlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vlan.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVlanID(v)
		return nil
	}
	return fmt.Errorf("unknown Vlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VlanMutation) AddedFields() []string {
	var fields []string
	if m.addvlan_id != nil {
		fields = append(fields, vlan.FieldVlanID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vlan.FieldVlanID:
		return m.AddedVlanID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vlan.FieldVlanID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVlanID(v)
		return nil
	}
	return fmt.Errorf("unknown Vlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VlanMutation) ResetField(name string) error {
	switch name {
	case vlan.FieldVlanID:
		m.ResetVlanID()
		return nil
	}
	return fmt.Errorf("unknown Vlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.vlans != nil {
		edges = append(edges, vlan.EdgeVlans)
	}
	if m.native_vlan != nil {
		edges = append(edges, vlan.EdgeNativeVlan)
	}
	if m.po_vlans != nil {
		edges = append(edges, vlan.EdgePoVlans)
	}
	if m.po_native_vlan != nil {
		edges = append(edges, vlan.EdgePoNativeVlan)
	}
	if m.on_device != nil {
		edges = append(edges, vlan.EdgeOnDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vlan.EdgeVlans:
		ids := make([]ent.Value, 0, len(m.vlans))
		for id := range m.vlans {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgeNativeVlan:
		ids := make([]ent.Value, 0, len(m.native_vlan))
		for id := range m.native_vlan {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgePoVlans:
		ids := make([]ent.Value, 0, len(m.po_vlans))
		for id := range m.po_vlans {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgePoNativeVlan:
		ids := make([]ent.Value, 0, len(m.po_native_vlan))
		for id := range m.po_native_vlan {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgeOnDevice:
		ids := make([]ent.Value, 0, len(m.on_device))
		for id := range m.on_device {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedvlans != nil {
		edges = append(edges, vlan.EdgeVlans)
	}
	if m.removednative_vlan != nil {
		edges = append(edges, vlan.EdgeNativeVlan)
	}
	if m.removedpo_vlans != nil {
		edges = append(edges, vlan.EdgePoVlans)
	}
	if m.removedpo_native_vlan != nil {
		edges = append(edges, vlan.EdgePoNativeVlan)
	}
	if m.removedon_device != nil {
		edges = append(edges, vlan.EdgeOnDevice)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vlan.EdgeVlans:
		ids := make([]ent.Value, 0, len(m.removedvlans))
		for id := range m.removedvlans {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgeNativeVlan:
		ids := make([]ent.Value, 0, len(m.removednative_vlan))
		for id := range m.removednative_vlan {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgePoVlans:
		ids := make([]ent.Value, 0, len(m.removedpo_vlans))
		for id := range m.removedpo_vlans {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgePoNativeVlan:
		ids := make([]ent.Value, 0, len(m.removedpo_native_vlan))
		for id := range m.removedpo_native_vlan {
			ids = append(ids, id)
		}
		return ids
	case vlan.EdgeOnDevice:
		ids := make([]ent.Value, 0, len(m.removedon_device))
		for id := range m.removedon_device {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedvlans {
		edges = append(edges, vlan.EdgeVlans)
	}
	if m.clearednative_vlan {
		edges = append(edges, vlan.EdgeNativeVlan)
	}
	if m.clearedpo_vlans {
		edges = append(edges, vlan.EdgePoVlans)
	}
	if m.clearedpo_native_vlan {
		edges = append(edges, vlan.EdgePoNativeVlan)
	}
	if m.clearedon_device {
		edges = append(edges, vlan.EdgeOnDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VlanMutation) EdgeCleared(name string) bool {
	switch name {
	case vlan.EdgeVlans:
		return m.clearedvlans
	case vlan.EdgeNativeVlan:
		return m.clearednative_vlan
	case vlan.EdgePoVlans:
		return m.clearedpo_vlans
	case vlan.EdgePoNativeVlan:
		return m.clearedpo_native_vlan
	case vlan.EdgeOnDevice:
		return m.clearedon_device
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VlanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Vlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VlanMutation) ResetEdge(name string) error {
	switch name {
	case vlan.EdgeVlans:
		m.ResetVlans()
		return nil
	case vlan.EdgeNativeVlan:
		m.ResetNativeVlan()
		return nil
	case vlan.EdgePoVlans:
		m.ResetPoVlans()
		return nil
	case vlan.EdgePoNativeVlan:
		m.ResetPoNativeVlan()
		return nil
	case vlan.EdgeOnDevice:
		m.ResetOnDevice()
		return nil
	}
	return fmt.Errorf("unknown Vlan edge %s", name)
}

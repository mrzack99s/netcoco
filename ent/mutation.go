// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/mrzack99s/netcoco/ent/administrator"
	"github.com/mrzack99s/netcoco/ent/device"
	"github.com/mrzack99s/netcoco/ent/devicetype"
	"github.com/mrzack99s/netcoco/ent/netinterface"
	"github.com/mrzack99s/netcoco/ent/netinterfacemode"
	"github.com/mrzack99s/netcoco/ent/nettopology"
	"github.com/mrzack99s/netcoco/ent/nettopologydevicemap"
	"github.com/mrzack99s/netcoco/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdministrator        = "Administrator"
	TypeDevice               = "Device"
	TypeDeviceType           = "DeviceType"
	TypeNetInterface         = "NetInterface"
	TypeNetInterfaceMode     = "NetInterfaceMode"
	TypeNetTopology          = "NetTopology"
	TypeNetTopologyDeviceMap = "NetTopologyDeviceMap"
)

// AdministratorMutation represents an operation that mutates the Administrator nodes in the graph.
type AdministratorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	password      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Administrator, error)
	predicates    []predicate.Administrator
}

var _ ent.Mutation = (*AdministratorMutation)(nil)

// administratorOption allows management of the mutation configuration using functional options.
type administratorOption func(*AdministratorMutation)

// newAdministratorMutation creates new mutation for the Administrator entity.
func newAdministratorMutation(c config, op Op, opts ...administratorOption) *AdministratorMutation {
	m := &AdministratorMutation{
		config:        c,
		op:            op,
		typ:           TypeAdministrator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdministratorID sets the ID field of the mutation.
func withAdministratorID(id int) administratorOption {
	return func(m *AdministratorMutation) {
		var (
			err   error
			once  sync.Once
			value *Administrator
		)
		m.oldValue = func(ctx context.Context) (*Administrator, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Administrator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdministrator sets the old Administrator of the mutation.
func withAdministrator(node *Administrator) administratorOption {
	return func(m *AdministratorMutation) {
		m.oldValue = func(context.Context) (*Administrator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdministratorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdministratorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AdministratorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the "username" field.
func (m *AdministratorMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdministratorMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Administrator entity.
// If the Administrator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdministratorMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdministratorMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdministratorMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdministratorMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Administrator entity.
// If the Administrator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdministratorMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdministratorMutation) ResetPassword() {
	m.password = nil
}

// Op returns the operation name.
func (m *AdministratorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Administrator).
func (m *AdministratorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdministratorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, administrator.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, administrator.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdministratorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case administrator.FieldUsername:
		return m.Username()
	case administrator.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdministratorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case administrator.FieldUsername:
		return m.OldUsername(ctx)
	case administrator.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Administrator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdministratorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case administrator.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case administrator.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Administrator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdministratorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdministratorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdministratorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Administrator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdministratorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdministratorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdministratorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Administrator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdministratorMutation) ResetField(name string) error {
	switch name {
	case administrator.FieldUsername:
		m.ResetUsername()
		return nil
	case administrator.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Administrator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdministratorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdministratorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdministratorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdministratorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdministratorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdministratorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdministratorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Administrator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdministratorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Administrator edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	device_name          *string
	device_hostname      *string
	device_username      *string
	device_password      *string
	device_secret        *string
	device_ssh_port      *int
	adddevice_ssh_port   *int
	device_commit_config *bool
	clearedFields        map[string]struct{}
	in_type              *int
	clearedin_type       bool
	interfaces           map[int]struct{}
	removedinterfaces    map[int]struct{}
	clearedinterfaces    bool
	in_topology          map[int]struct{}
	removedin_topology   map[int]struct{}
	clearedin_topology   bool
	done                 bool
	oldValue             func(context.Context) (*Device, error)
	predicates           []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDeviceName sets the "device_name" field.
func (m *DeviceMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *DeviceMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *DeviceMutation) ResetDeviceName() {
	m.device_name = nil
}

// SetDeviceHostname sets the "device_hostname" field.
func (m *DeviceMutation) SetDeviceHostname(s string) {
	m.device_hostname = &s
}

// DeviceHostname returns the value of the "device_hostname" field in the mutation.
func (m *DeviceMutation) DeviceHostname() (r string, exists bool) {
	v := m.device_hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceHostname returns the old "device_hostname" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceHostname: %w", err)
	}
	return oldValue.DeviceHostname, nil
}

// ResetDeviceHostname resets all changes to the "device_hostname" field.
func (m *DeviceMutation) ResetDeviceHostname() {
	m.device_hostname = nil
}

// SetDeviceUsername sets the "device_username" field.
func (m *DeviceMutation) SetDeviceUsername(s string) {
	m.device_username = &s
}

// DeviceUsername returns the value of the "device_username" field in the mutation.
func (m *DeviceMutation) DeviceUsername() (r string, exists bool) {
	v := m.device_username
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceUsername returns the old "device_username" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceUsername: %w", err)
	}
	return oldValue.DeviceUsername, nil
}

// ClearDeviceUsername clears the value of the "device_username" field.
func (m *DeviceMutation) ClearDeviceUsername() {
	m.device_username = nil
	m.clearedFields[device.FieldDeviceUsername] = struct{}{}
}

// DeviceUsernameCleared returns if the "device_username" field was cleared in this mutation.
func (m *DeviceMutation) DeviceUsernameCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceUsername]
	return ok
}

// ResetDeviceUsername resets all changes to the "device_username" field.
func (m *DeviceMutation) ResetDeviceUsername() {
	m.device_username = nil
	delete(m.clearedFields, device.FieldDeviceUsername)
}

// SetDevicePassword sets the "device_password" field.
func (m *DeviceMutation) SetDevicePassword(s string) {
	m.device_password = &s
}

// DevicePassword returns the value of the "device_password" field in the mutation.
func (m *DeviceMutation) DevicePassword() (r string, exists bool) {
	v := m.device_password
	if v == nil {
		return
	}
	return *v, true
}

// OldDevicePassword returns the old "device_password" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDevicePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDevicePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDevicePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevicePassword: %w", err)
	}
	return oldValue.DevicePassword, nil
}

// ClearDevicePassword clears the value of the "device_password" field.
func (m *DeviceMutation) ClearDevicePassword() {
	m.device_password = nil
	m.clearedFields[device.FieldDevicePassword] = struct{}{}
}

// DevicePasswordCleared returns if the "device_password" field was cleared in this mutation.
func (m *DeviceMutation) DevicePasswordCleared() bool {
	_, ok := m.clearedFields[device.FieldDevicePassword]
	return ok
}

// ResetDevicePassword resets all changes to the "device_password" field.
func (m *DeviceMutation) ResetDevicePassword() {
	m.device_password = nil
	delete(m.clearedFields, device.FieldDevicePassword)
}

// SetDeviceSecret sets the "device_secret" field.
func (m *DeviceMutation) SetDeviceSecret(s string) {
	m.device_secret = &s
}

// DeviceSecret returns the value of the "device_secret" field in the mutation.
func (m *DeviceMutation) DeviceSecret() (r string, exists bool) {
	v := m.device_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSecret returns the old "device_secret" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSecret: %w", err)
	}
	return oldValue.DeviceSecret, nil
}

// ClearDeviceSecret clears the value of the "device_secret" field.
func (m *DeviceMutation) ClearDeviceSecret() {
	m.device_secret = nil
	m.clearedFields[device.FieldDeviceSecret] = struct{}{}
}

// DeviceSecretCleared returns if the "device_secret" field was cleared in this mutation.
func (m *DeviceMutation) DeviceSecretCleared() bool {
	_, ok := m.clearedFields[device.FieldDeviceSecret]
	return ok
}

// ResetDeviceSecret resets all changes to the "device_secret" field.
func (m *DeviceMutation) ResetDeviceSecret() {
	m.device_secret = nil
	delete(m.clearedFields, device.FieldDeviceSecret)
}

// SetDeviceSSHPort sets the "device_ssh_port" field.
func (m *DeviceMutation) SetDeviceSSHPort(i int) {
	m.device_ssh_port = &i
	m.adddevice_ssh_port = nil
}

// DeviceSSHPort returns the value of the "device_ssh_port" field in the mutation.
func (m *DeviceMutation) DeviceSSHPort() (r int, exists bool) {
	v := m.device_ssh_port
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceSSHPort returns the old "device_ssh_port" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceSSHPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceSSHPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceSSHPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceSSHPort: %w", err)
	}
	return oldValue.DeviceSSHPort, nil
}

// AddDeviceSSHPort adds i to the "device_ssh_port" field.
func (m *DeviceMutation) AddDeviceSSHPort(i int) {
	if m.adddevice_ssh_port != nil {
		*m.adddevice_ssh_port += i
	} else {
		m.adddevice_ssh_port = &i
	}
}

// AddedDeviceSSHPort returns the value that was added to the "device_ssh_port" field in this mutation.
func (m *DeviceMutation) AddedDeviceSSHPort() (r int, exists bool) {
	v := m.adddevice_ssh_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceSSHPort resets all changes to the "device_ssh_port" field.
func (m *DeviceMutation) ResetDeviceSSHPort() {
	m.device_ssh_port = nil
	m.adddevice_ssh_port = nil
}

// SetDeviceCommitConfig sets the "device_commit_config" field.
func (m *DeviceMutation) SetDeviceCommitConfig(b bool) {
	m.device_commit_config = &b
}

// DeviceCommitConfig returns the value of the "device_commit_config" field in the mutation.
func (m *DeviceMutation) DeviceCommitConfig() (r bool, exists bool) {
	v := m.device_commit_config
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceCommitConfig returns the old "device_commit_config" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceCommitConfig(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceCommitConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceCommitConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceCommitConfig: %w", err)
	}
	return oldValue.DeviceCommitConfig, nil
}

// ResetDeviceCommitConfig resets all changes to the "device_commit_config" field.
func (m *DeviceMutation) ResetDeviceCommitConfig() {
	m.device_commit_config = nil
}

// SetInTypeID sets the "in_type" edge to the DeviceType entity by id.
func (m *DeviceMutation) SetInTypeID(id int) {
	m.in_type = &id
}

// ClearInType clears the "in_type" edge to the DeviceType entity.
func (m *DeviceMutation) ClearInType() {
	m.clearedin_type = true
}

// InTypeCleared reports if the "in_type" edge to the DeviceType entity was cleared.
func (m *DeviceMutation) InTypeCleared() bool {
	return m.clearedin_type
}

// InTypeID returns the "in_type" edge ID in the mutation.
func (m *DeviceMutation) InTypeID() (id int, exists bool) {
	if m.in_type != nil {
		return *m.in_type, true
	}
	return
}

// InTypeIDs returns the "in_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InTypeID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) InTypeIDs() (ids []int) {
	if id := m.in_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInType resets all changes to the "in_type" edge.
func (m *DeviceMutation) ResetInType() {
	m.in_type = nil
	m.clearedin_type = false
}

// AddInterfaceIDs adds the "interfaces" edge to the NetInterface entity by ids.
func (m *DeviceMutation) AddInterfaceIDs(ids ...int) {
	if m.interfaces == nil {
		m.interfaces = make(map[int]struct{})
	}
	for i := range ids {
		m.interfaces[ids[i]] = struct{}{}
	}
}

// ClearInterfaces clears the "interfaces" edge to the NetInterface entity.
func (m *DeviceMutation) ClearInterfaces() {
	m.clearedinterfaces = true
}

// InterfacesCleared reports if the "interfaces" edge to the NetInterface entity was cleared.
func (m *DeviceMutation) InterfacesCleared() bool {
	return m.clearedinterfaces
}

// RemoveInterfaceIDs removes the "interfaces" edge to the NetInterface entity by IDs.
func (m *DeviceMutation) RemoveInterfaceIDs(ids ...int) {
	if m.removedinterfaces == nil {
		m.removedinterfaces = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinterfaces[ids[i]] = struct{}{}
	}
}

// RemovedInterfaces returns the removed IDs of the "interfaces" edge to the NetInterface entity.
func (m *DeviceMutation) RemovedInterfacesIDs() (ids []int) {
	for id := range m.removedinterfaces {
		ids = append(ids, id)
	}
	return
}

// InterfacesIDs returns the "interfaces" edge IDs in the mutation.
func (m *DeviceMutation) InterfacesIDs() (ids []int) {
	for id := range m.interfaces {
		ids = append(ids, id)
	}
	return
}

// ResetInterfaces resets all changes to the "interfaces" edge.
func (m *DeviceMutation) ResetInterfaces() {
	m.interfaces = nil
	m.clearedinterfaces = false
	m.removedinterfaces = nil
}

// AddInTopologyIDs adds the "in_topology" edge to the NetTopologyDeviceMap entity by ids.
func (m *DeviceMutation) AddInTopologyIDs(ids ...int) {
	if m.in_topology == nil {
		m.in_topology = make(map[int]struct{})
	}
	for i := range ids {
		m.in_topology[ids[i]] = struct{}{}
	}
}

// ClearInTopology clears the "in_topology" edge to the NetTopologyDeviceMap entity.
func (m *DeviceMutation) ClearInTopology() {
	m.clearedin_topology = true
}

// InTopologyCleared reports if the "in_topology" edge to the NetTopologyDeviceMap entity was cleared.
func (m *DeviceMutation) InTopologyCleared() bool {
	return m.clearedin_topology
}

// RemoveInTopologyIDs removes the "in_topology" edge to the NetTopologyDeviceMap entity by IDs.
func (m *DeviceMutation) RemoveInTopologyIDs(ids ...int) {
	if m.removedin_topology == nil {
		m.removedin_topology = make(map[int]struct{})
	}
	for i := range ids {
		m.removedin_topology[ids[i]] = struct{}{}
	}
}

// RemovedInTopology returns the removed IDs of the "in_topology" edge to the NetTopologyDeviceMap entity.
func (m *DeviceMutation) RemovedInTopologyIDs() (ids []int) {
	for id := range m.removedin_topology {
		ids = append(ids, id)
	}
	return
}

// InTopologyIDs returns the "in_topology" edge IDs in the mutation.
func (m *DeviceMutation) InTopologyIDs() (ids []int) {
	for id := range m.in_topology {
		ids = append(ids, id)
	}
	return
}

// ResetInTopology resets all changes to the "in_topology" edge.
func (m *DeviceMutation) ResetInTopology() {
	m.in_topology = nil
	m.clearedin_topology = false
	m.removedin_topology = nil
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.device_name != nil {
		fields = append(fields, device.FieldDeviceName)
	}
	if m.device_hostname != nil {
		fields = append(fields, device.FieldDeviceHostname)
	}
	if m.device_username != nil {
		fields = append(fields, device.FieldDeviceUsername)
	}
	if m.device_password != nil {
		fields = append(fields, device.FieldDevicePassword)
	}
	if m.device_secret != nil {
		fields = append(fields, device.FieldDeviceSecret)
	}
	if m.device_ssh_port != nil {
		fields = append(fields, device.FieldDeviceSSHPort)
	}
	if m.device_commit_config != nil {
		fields = append(fields, device.FieldDeviceCommitConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDeviceName:
		return m.DeviceName()
	case device.FieldDeviceHostname:
		return m.DeviceHostname()
	case device.FieldDeviceUsername:
		return m.DeviceUsername()
	case device.FieldDevicePassword:
		return m.DevicePassword()
	case device.FieldDeviceSecret:
		return m.DeviceSecret()
	case device.FieldDeviceSSHPort:
		return m.DeviceSSHPort()
	case device.FieldDeviceCommitConfig:
		return m.DeviceCommitConfig()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case device.FieldDeviceHostname:
		return m.OldDeviceHostname(ctx)
	case device.FieldDeviceUsername:
		return m.OldDeviceUsername(ctx)
	case device.FieldDevicePassword:
		return m.OldDevicePassword(ctx)
	case device.FieldDeviceSecret:
		return m.OldDeviceSecret(ctx)
	case device.FieldDeviceSSHPort:
		return m.OldDeviceSSHPort(ctx)
	case device.FieldDeviceCommitConfig:
		return m.OldDeviceCommitConfig(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case device.FieldDeviceHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceHostname(v)
		return nil
	case device.FieldDeviceUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceUsername(v)
		return nil
	case device.FieldDevicePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevicePassword(v)
		return nil
	case device.FieldDeviceSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSecret(v)
		return nil
	case device.FieldDeviceSSHPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceSSHPort(v)
		return nil
	case device.FieldDeviceCommitConfig:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceCommitConfig(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_ssh_port != nil {
		fields = append(fields, device.FieldDeviceSSHPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDeviceSSHPort:
		return m.AddedDeviceSSHPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldDeviceSSHPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceSSHPort(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldDeviceUsername) {
		fields = append(fields, device.FieldDeviceUsername)
	}
	if m.FieldCleared(device.FieldDevicePassword) {
		fields = append(fields, device.FieldDevicePassword)
	}
	if m.FieldCleared(device.FieldDeviceSecret) {
		fields = append(fields, device.FieldDeviceSecret)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldDeviceUsername:
		m.ClearDeviceUsername()
		return nil
	case device.FieldDevicePassword:
		m.ClearDevicePassword()
		return nil
	case device.FieldDeviceSecret:
		m.ClearDeviceSecret()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case device.FieldDeviceHostname:
		m.ResetDeviceHostname()
		return nil
	case device.FieldDeviceUsername:
		m.ResetDeviceUsername()
		return nil
	case device.FieldDevicePassword:
		m.ResetDevicePassword()
		return nil
	case device.FieldDeviceSecret:
		m.ResetDeviceSecret()
		return nil
	case device.FieldDeviceSSHPort:
		m.ResetDeviceSSHPort()
		return nil
	case device.FieldDeviceCommitConfig:
		m.ResetDeviceCommitConfig()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.in_type != nil {
		edges = append(edges, device.EdgeInType)
	}
	if m.interfaces != nil {
		edges = append(edges, device.EdgeInterfaces)
	}
	if m.in_topology != nil {
		edges = append(edges, device.EdgeInTopology)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeInType:
		if id := m.in_type; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeInterfaces:
		ids := make([]ent.Value, 0, len(m.interfaces))
		for id := range m.interfaces {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeInTopology:
		ids := make([]ent.Value, 0, len(m.in_topology))
		for id := range m.in_topology {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinterfaces != nil {
		edges = append(edges, device.EdgeInterfaces)
	}
	if m.removedin_topology != nil {
		edges = append(edges, device.EdgeInTopology)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeInterfaces:
		ids := make([]ent.Value, 0, len(m.removedinterfaces))
		for id := range m.removedinterfaces {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeInTopology:
		ids := make([]ent.Value, 0, len(m.removedin_topology))
		for id := range m.removedin_topology {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedin_type {
		edges = append(edges, device.EdgeInType)
	}
	if m.clearedinterfaces {
		edges = append(edges, device.EdgeInterfaces)
	}
	if m.clearedin_topology {
		edges = append(edges, device.EdgeInTopology)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeInType:
		return m.clearedin_type
	case device.EdgeInterfaces:
		return m.clearedinterfaces
	case device.EdgeInTopology:
		return m.clearedin_topology
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeInType:
		m.ClearInType()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeInType:
		m.ResetInType()
		return nil
	case device.EdgeInterfaces:
		m.ResetInterfaces()
		return nil
	case device.EdgeInTopology:
		m.ResetInTopology()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DeviceTypeMutation represents an operation that mutates the DeviceType nodes in the graph.
type DeviceTypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	device_type_name *string
	clearedFields    map[string]struct{}
	types            map[int]struct{}
	removedtypes     map[int]struct{}
	clearedtypes     bool
	done             bool
	oldValue         func(context.Context) (*DeviceType, error)
	predicates       []predicate.DeviceType
}

var _ ent.Mutation = (*DeviceTypeMutation)(nil)

// devicetypeOption allows management of the mutation configuration using functional options.
type devicetypeOption func(*DeviceTypeMutation)

// newDeviceTypeMutation creates new mutation for the DeviceType entity.
func newDeviceTypeMutation(c config, op Op, opts ...devicetypeOption) *DeviceTypeMutation {
	m := &DeviceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceTypeID sets the ID field of the mutation.
func withDeviceTypeID(id int) devicetypeOption {
	return func(m *DeviceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceType
		)
		m.oldValue = func(ctx context.Context) (*DeviceType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceType sets the old DeviceType of the mutation.
func withDeviceType(node *DeviceType) devicetypeOption {
	return func(m *DeviceTypeMutation) {
		m.oldValue = func(context.Context) (*DeviceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DeviceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDeviceTypeName sets the "device_type_name" field.
func (m *DeviceTypeMutation) SetDeviceTypeName(s string) {
	m.device_type_name = &s
}

// DeviceTypeName returns the value of the "device_type_name" field in the mutation.
func (m *DeviceTypeMutation) DeviceTypeName() (r string, exists bool) {
	v := m.device_type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceTypeName returns the old "device_type_name" field's value of the DeviceType entity.
// If the DeviceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceTypeMutation) OldDeviceTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceTypeName: %w", err)
	}
	return oldValue.DeviceTypeName, nil
}

// ResetDeviceTypeName resets all changes to the "device_type_name" field.
func (m *DeviceTypeMutation) ResetDeviceTypeName() {
	m.device_type_name = nil
}

// AddTypeIDs adds the "types" edge to the Device entity by ids.
func (m *DeviceTypeMutation) AddTypeIDs(ids ...int) {
	if m.types == nil {
		m.types = make(map[int]struct{})
	}
	for i := range ids {
		m.types[ids[i]] = struct{}{}
	}
}

// ClearTypes clears the "types" edge to the Device entity.
func (m *DeviceTypeMutation) ClearTypes() {
	m.clearedtypes = true
}

// TypesCleared reports if the "types" edge to the Device entity was cleared.
func (m *DeviceTypeMutation) TypesCleared() bool {
	return m.clearedtypes
}

// RemoveTypeIDs removes the "types" edge to the Device entity by IDs.
func (m *DeviceTypeMutation) RemoveTypeIDs(ids ...int) {
	if m.removedtypes == nil {
		m.removedtypes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtypes[ids[i]] = struct{}{}
	}
}

// RemovedTypes returns the removed IDs of the "types" edge to the Device entity.
func (m *DeviceTypeMutation) RemovedTypesIDs() (ids []int) {
	for id := range m.removedtypes {
		ids = append(ids, id)
	}
	return
}

// TypesIDs returns the "types" edge IDs in the mutation.
func (m *DeviceTypeMutation) TypesIDs() (ids []int) {
	for id := range m.types {
		ids = append(ids, id)
	}
	return
}

// ResetTypes resets all changes to the "types" edge.
func (m *DeviceTypeMutation) ResetTypes() {
	m.types = nil
	m.clearedtypes = false
	m.removedtypes = nil
}

// Op returns the operation name.
func (m *DeviceTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DeviceType).
func (m *DeviceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.device_type_name != nil {
		fields = append(fields, devicetype.FieldDeviceTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case devicetype.FieldDeviceTypeName:
		return m.DeviceTypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case devicetype.FieldDeviceTypeName:
		return m.OldDeviceTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case devicetype.FieldDeviceTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceTypeMutation) ResetField(name string) error {
	switch name {
	case devicetype.FieldDeviceTypeName:
		m.ResetDeviceTypeName()
		return nil
	}
	return fmt.Errorf("unknown DeviceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.types != nil {
		edges = append(edges, devicetype.EdgeTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case devicetype.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.types))
		for id := range m.types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtypes != nil {
		edges = append(edges, devicetype.EdgeTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case devicetype.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.removedtypes))
		for id := range m.removedtypes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtypes {
		edges = append(edges, devicetype.EdgeTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case devicetype.EdgeTypes:
		return m.clearedtypes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceTypeMutation) ResetEdge(name string) error {
	switch name {
	case devicetype.EdgeTypes:
		m.ResetTypes()
		return nil
	}
	return fmt.Errorf("unknown DeviceType edge %s", name)
}

// NetInterfaceMutation represents an operation that mutates the NetInterface nodes in the graph.
type NetInterfaceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	interface_name        *string
	interface_vlan        *string
	interface_native_vlan *string
	clearedFields         map[string]struct{}
	on_device             *int
	clearedon_device      bool
	mode                  *int
	clearedmode           bool
	done                  bool
	oldValue              func(context.Context) (*NetInterface, error)
	predicates            []predicate.NetInterface
}

var _ ent.Mutation = (*NetInterfaceMutation)(nil)

// netinterfaceOption allows management of the mutation configuration using functional options.
type netinterfaceOption func(*NetInterfaceMutation)

// newNetInterfaceMutation creates new mutation for the NetInterface entity.
func newNetInterfaceMutation(c config, op Op, opts ...netinterfaceOption) *NetInterfaceMutation {
	m := &NetInterfaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNetInterface,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetInterfaceID sets the ID field of the mutation.
func withNetInterfaceID(id int) netinterfaceOption {
	return func(m *NetInterfaceMutation) {
		var (
			err   error
			once  sync.Once
			value *NetInterface
		)
		m.oldValue = func(ctx context.Context) (*NetInterface, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetInterface.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetInterface sets the old NetInterface of the mutation.
func withNetInterface(node *NetInterface) netinterfaceOption {
	return func(m *NetInterfaceMutation) {
		m.oldValue = func(context.Context) (*NetInterface, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetInterfaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetInterfaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetInterfaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInterfaceName sets the "interface_name" field.
func (m *NetInterfaceMutation) SetInterfaceName(s string) {
	m.interface_name = &s
}

// InterfaceName returns the value of the "interface_name" field in the mutation.
func (m *NetInterfaceMutation) InterfaceName() (r string, exists bool) {
	v := m.interface_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceName returns the old "interface_name" field's value of the NetInterface entity.
// If the NetInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetInterfaceMutation) OldInterfaceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInterfaceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInterfaceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceName: %w", err)
	}
	return oldValue.InterfaceName, nil
}

// ResetInterfaceName resets all changes to the "interface_name" field.
func (m *NetInterfaceMutation) ResetInterfaceName() {
	m.interface_name = nil
}

// SetInterfaceVlan sets the "interface_vlan" field.
func (m *NetInterfaceMutation) SetInterfaceVlan(s string) {
	m.interface_vlan = &s
}

// InterfaceVlan returns the value of the "interface_vlan" field in the mutation.
func (m *NetInterfaceMutation) InterfaceVlan() (r string, exists bool) {
	v := m.interface_vlan
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceVlan returns the old "interface_vlan" field's value of the NetInterface entity.
// If the NetInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetInterfaceMutation) OldInterfaceVlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInterfaceVlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInterfaceVlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceVlan: %w", err)
	}
	return oldValue.InterfaceVlan, nil
}

// ResetInterfaceVlan resets all changes to the "interface_vlan" field.
func (m *NetInterfaceMutation) ResetInterfaceVlan() {
	m.interface_vlan = nil
}

// SetInterfaceNativeVlan sets the "interface_native_vlan" field.
func (m *NetInterfaceMutation) SetInterfaceNativeVlan(s string) {
	m.interface_native_vlan = &s
}

// InterfaceNativeVlan returns the value of the "interface_native_vlan" field in the mutation.
func (m *NetInterfaceMutation) InterfaceNativeVlan() (r string, exists bool) {
	v := m.interface_native_vlan
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceNativeVlan returns the old "interface_native_vlan" field's value of the NetInterface entity.
// If the NetInterface object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetInterfaceMutation) OldInterfaceNativeVlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInterfaceNativeVlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInterfaceNativeVlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceNativeVlan: %w", err)
	}
	return oldValue.InterfaceNativeVlan, nil
}

// ResetInterfaceNativeVlan resets all changes to the "interface_native_vlan" field.
func (m *NetInterfaceMutation) ResetInterfaceNativeVlan() {
	m.interface_native_vlan = nil
}

// SetOnDeviceID sets the "on_device" edge to the Device entity by id.
func (m *NetInterfaceMutation) SetOnDeviceID(id int) {
	m.on_device = &id
}

// ClearOnDevice clears the "on_device" edge to the Device entity.
func (m *NetInterfaceMutation) ClearOnDevice() {
	m.clearedon_device = true
}

// OnDeviceCleared reports if the "on_device" edge to the Device entity was cleared.
func (m *NetInterfaceMutation) OnDeviceCleared() bool {
	return m.clearedon_device
}

// OnDeviceID returns the "on_device" edge ID in the mutation.
func (m *NetInterfaceMutation) OnDeviceID() (id int, exists bool) {
	if m.on_device != nil {
		return *m.on_device, true
	}
	return
}

// OnDeviceIDs returns the "on_device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OnDeviceID instead. It exists only for internal usage by the builders.
func (m *NetInterfaceMutation) OnDeviceIDs() (ids []int) {
	if id := m.on_device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOnDevice resets all changes to the "on_device" edge.
func (m *NetInterfaceMutation) ResetOnDevice() {
	m.on_device = nil
	m.clearedon_device = false
}

// SetModeID sets the "mode" edge to the NetInterfaceMode entity by id.
func (m *NetInterfaceMutation) SetModeID(id int) {
	m.mode = &id
}

// ClearMode clears the "mode" edge to the NetInterfaceMode entity.
func (m *NetInterfaceMutation) ClearMode() {
	m.clearedmode = true
}

// ModeCleared reports if the "mode" edge to the NetInterfaceMode entity was cleared.
func (m *NetInterfaceMutation) ModeCleared() bool {
	return m.clearedmode
}

// ModeID returns the "mode" edge ID in the mutation.
func (m *NetInterfaceMutation) ModeID() (id int, exists bool) {
	if m.mode != nil {
		return *m.mode, true
	}
	return
}

// ModeIDs returns the "mode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModeID instead. It exists only for internal usage by the builders.
func (m *NetInterfaceMutation) ModeIDs() (ids []int) {
	if id := m.mode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMode resets all changes to the "mode" edge.
func (m *NetInterfaceMutation) ResetMode() {
	m.mode = nil
	m.clearedmode = false
}

// Op returns the operation name.
func (m *NetInterfaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetInterface).
func (m *NetInterfaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetInterfaceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.interface_name != nil {
		fields = append(fields, netinterface.FieldInterfaceName)
	}
	if m.interface_vlan != nil {
		fields = append(fields, netinterface.FieldInterfaceVlan)
	}
	if m.interface_native_vlan != nil {
		fields = append(fields, netinterface.FieldInterfaceNativeVlan)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetInterfaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case netinterface.FieldInterfaceName:
		return m.InterfaceName()
	case netinterface.FieldInterfaceVlan:
		return m.InterfaceVlan()
	case netinterface.FieldInterfaceNativeVlan:
		return m.InterfaceNativeVlan()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetInterfaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case netinterface.FieldInterfaceName:
		return m.OldInterfaceName(ctx)
	case netinterface.FieldInterfaceVlan:
		return m.OldInterfaceVlan(ctx)
	case netinterface.FieldInterfaceNativeVlan:
		return m.OldInterfaceNativeVlan(ctx)
	}
	return nil, fmt.Errorf("unknown NetInterface field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetInterfaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case netinterface.FieldInterfaceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceName(v)
		return nil
	case netinterface.FieldInterfaceVlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceVlan(v)
		return nil
	case netinterface.FieldInterfaceNativeVlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceNativeVlan(v)
		return nil
	}
	return fmt.Errorf("unknown NetInterface field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetInterfaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetInterfaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetInterfaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetInterface numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetInterfaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetInterfaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetInterfaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetInterface nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetInterfaceMutation) ResetField(name string) error {
	switch name {
	case netinterface.FieldInterfaceName:
		m.ResetInterfaceName()
		return nil
	case netinterface.FieldInterfaceVlan:
		m.ResetInterfaceVlan()
		return nil
	case netinterface.FieldInterfaceNativeVlan:
		m.ResetInterfaceNativeVlan()
		return nil
	}
	return fmt.Errorf("unknown NetInterface field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetInterfaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.on_device != nil {
		edges = append(edges, netinterface.EdgeOnDevice)
	}
	if m.mode != nil {
		edges = append(edges, netinterface.EdgeMode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetInterfaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case netinterface.EdgeOnDevice:
		if id := m.on_device; id != nil {
			return []ent.Value{*id}
		}
	case netinterface.EdgeMode:
		if id := m.mode; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetInterfaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetInterfaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetInterfaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedon_device {
		edges = append(edges, netinterface.EdgeOnDevice)
	}
	if m.clearedmode {
		edges = append(edges, netinterface.EdgeMode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetInterfaceMutation) EdgeCleared(name string) bool {
	switch name {
	case netinterface.EdgeOnDevice:
		return m.clearedon_device
	case netinterface.EdgeMode:
		return m.clearedmode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetInterfaceMutation) ClearEdge(name string) error {
	switch name {
	case netinterface.EdgeOnDevice:
		m.ClearOnDevice()
		return nil
	case netinterface.EdgeMode:
		m.ClearMode()
		return nil
	}
	return fmt.Errorf("unknown NetInterface unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetInterfaceMutation) ResetEdge(name string) error {
	switch name {
	case netinterface.EdgeOnDevice:
		m.ResetOnDevice()
		return nil
	case netinterface.EdgeMode:
		m.ResetMode()
		return nil
	}
	return fmt.Errorf("unknown NetInterface edge %s", name)
}

// NetInterfaceModeMutation represents an operation that mutates the NetInterfaceMode nodes in the graph.
type NetInterfaceModeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	interface_mode *string
	clearedFields  map[string]struct{}
	modes          map[int]struct{}
	removedmodes   map[int]struct{}
	clearedmodes   bool
	done           bool
	oldValue       func(context.Context) (*NetInterfaceMode, error)
	predicates     []predicate.NetInterfaceMode
}

var _ ent.Mutation = (*NetInterfaceModeMutation)(nil)

// netinterfacemodeOption allows management of the mutation configuration using functional options.
type netinterfacemodeOption func(*NetInterfaceModeMutation)

// newNetInterfaceModeMutation creates new mutation for the NetInterfaceMode entity.
func newNetInterfaceModeMutation(c config, op Op, opts ...netinterfacemodeOption) *NetInterfaceModeMutation {
	m := &NetInterfaceModeMutation{
		config:        c,
		op:            op,
		typ:           TypeNetInterfaceMode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetInterfaceModeID sets the ID field of the mutation.
func withNetInterfaceModeID(id int) netinterfacemodeOption {
	return func(m *NetInterfaceModeMutation) {
		var (
			err   error
			once  sync.Once
			value *NetInterfaceMode
		)
		m.oldValue = func(ctx context.Context) (*NetInterfaceMode, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetInterfaceMode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetInterfaceMode sets the old NetInterfaceMode of the mutation.
func withNetInterfaceMode(node *NetInterfaceMode) netinterfacemodeOption {
	return func(m *NetInterfaceModeMutation) {
		m.oldValue = func(context.Context) (*NetInterfaceMode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetInterfaceModeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetInterfaceModeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetInterfaceModeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInterfaceMode sets the "interface_mode" field.
func (m *NetInterfaceModeMutation) SetInterfaceMode(s string) {
	m.interface_mode = &s
}

// InterfaceMode returns the value of the "interface_mode" field in the mutation.
func (m *NetInterfaceModeMutation) InterfaceMode() (r string, exists bool) {
	v := m.interface_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldInterfaceMode returns the old "interface_mode" field's value of the NetInterfaceMode entity.
// If the NetInterfaceMode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetInterfaceModeMutation) OldInterfaceMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInterfaceMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInterfaceMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterfaceMode: %w", err)
	}
	return oldValue.InterfaceMode, nil
}

// ResetInterfaceMode resets all changes to the "interface_mode" field.
func (m *NetInterfaceModeMutation) ResetInterfaceMode() {
	m.interface_mode = nil
}

// AddModeIDs adds the "modes" edge to the NetInterface entity by ids.
func (m *NetInterfaceModeMutation) AddModeIDs(ids ...int) {
	if m.modes == nil {
		m.modes = make(map[int]struct{})
	}
	for i := range ids {
		m.modes[ids[i]] = struct{}{}
	}
}

// ClearModes clears the "modes" edge to the NetInterface entity.
func (m *NetInterfaceModeMutation) ClearModes() {
	m.clearedmodes = true
}

// ModesCleared reports if the "modes" edge to the NetInterface entity was cleared.
func (m *NetInterfaceModeMutation) ModesCleared() bool {
	return m.clearedmodes
}

// RemoveModeIDs removes the "modes" edge to the NetInterface entity by IDs.
func (m *NetInterfaceModeMutation) RemoveModeIDs(ids ...int) {
	if m.removedmodes == nil {
		m.removedmodes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmodes[ids[i]] = struct{}{}
	}
}

// RemovedModes returns the removed IDs of the "modes" edge to the NetInterface entity.
func (m *NetInterfaceModeMutation) RemovedModesIDs() (ids []int) {
	for id := range m.removedmodes {
		ids = append(ids, id)
	}
	return
}

// ModesIDs returns the "modes" edge IDs in the mutation.
func (m *NetInterfaceModeMutation) ModesIDs() (ids []int) {
	for id := range m.modes {
		ids = append(ids, id)
	}
	return
}

// ResetModes resets all changes to the "modes" edge.
func (m *NetInterfaceModeMutation) ResetModes() {
	m.modes = nil
	m.clearedmodes = false
	m.removedmodes = nil
}

// Op returns the operation name.
func (m *NetInterfaceModeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetInterfaceMode).
func (m *NetInterfaceModeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetInterfaceModeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.interface_mode != nil {
		fields = append(fields, netinterfacemode.FieldInterfaceMode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetInterfaceModeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case netinterfacemode.FieldInterfaceMode:
		return m.InterfaceMode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetInterfaceModeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case netinterfacemode.FieldInterfaceMode:
		return m.OldInterfaceMode(ctx)
	}
	return nil, fmt.Errorf("unknown NetInterfaceMode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetInterfaceModeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case netinterfacemode.FieldInterfaceMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterfaceMode(v)
		return nil
	}
	return fmt.Errorf("unknown NetInterfaceMode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetInterfaceModeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetInterfaceModeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetInterfaceModeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetInterfaceMode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetInterfaceModeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetInterfaceModeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetInterfaceModeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetInterfaceMode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetInterfaceModeMutation) ResetField(name string) error {
	switch name {
	case netinterfacemode.FieldInterfaceMode:
		m.ResetInterfaceMode()
		return nil
	}
	return fmt.Errorf("unknown NetInterfaceMode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetInterfaceModeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.modes != nil {
		edges = append(edges, netinterfacemode.EdgeModes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetInterfaceModeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case netinterfacemode.EdgeModes:
		ids := make([]ent.Value, 0, len(m.modes))
		for id := range m.modes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetInterfaceModeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmodes != nil {
		edges = append(edges, netinterfacemode.EdgeModes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetInterfaceModeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case netinterfacemode.EdgeModes:
		ids := make([]ent.Value, 0, len(m.removedmodes))
		for id := range m.removedmodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetInterfaceModeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmodes {
		edges = append(edges, netinterfacemode.EdgeModes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetInterfaceModeMutation) EdgeCleared(name string) bool {
	switch name {
	case netinterfacemode.EdgeModes:
		return m.clearedmodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetInterfaceModeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NetInterfaceMode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetInterfaceModeMutation) ResetEdge(name string) error {
	switch name {
	case netinterfacemode.EdgeModes:
		m.ResetModes()
		return nil
	}
	return fmt.Errorf("unknown NetInterfaceMode edge %s", name)
}

// NetTopologyMutation represents an operation that mutates the NetTopology nodes in the graph.
type NetTopologyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	topology_name        *string
	topology_description *string
	clearedFields        map[string]struct{}
	topology             map[int]struct{}
	removedtopology      map[int]struct{}
	clearedtopology      bool
	done                 bool
	oldValue             func(context.Context) (*NetTopology, error)
	predicates           []predicate.NetTopology
}

var _ ent.Mutation = (*NetTopologyMutation)(nil)

// nettopologyOption allows management of the mutation configuration using functional options.
type nettopologyOption func(*NetTopologyMutation)

// newNetTopologyMutation creates new mutation for the NetTopology entity.
func newNetTopologyMutation(c config, op Op, opts ...nettopologyOption) *NetTopologyMutation {
	m := &NetTopologyMutation{
		config:        c,
		op:            op,
		typ:           TypeNetTopology,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetTopologyID sets the ID field of the mutation.
func withNetTopologyID(id int) nettopologyOption {
	return func(m *NetTopologyMutation) {
		var (
			err   error
			once  sync.Once
			value *NetTopology
		)
		m.oldValue = func(ctx context.Context) (*NetTopology, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetTopology.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetTopology sets the old NetTopology of the mutation.
func withNetTopology(node *NetTopology) nettopologyOption {
	return func(m *NetTopologyMutation) {
		m.oldValue = func(context.Context) (*NetTopology, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetTopologyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetTopologyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetTopologyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTopologyName sets the "topology_name" field.
func (m *NetTopologyMutation) SetTopologyName(s string) {
	m.topology_name = &s
}

// TopologyName returns the value of the "topology_name" field in the mutation.
func (m *NetTopologyMutation) TopologyName() (r string, exists bool) {
	v := m.topology_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTopologyName returns the old "topology_name" field's value of the NetTopology entity.
// If the NetTopology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetTopologyMutation) OldTopologyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTopologyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTopologyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopologyName: %w", err)
	}
	return oldValue.TopologyName, nil
}

// ResetTopologyName resets all changes to the "topology_name" field.
func (m *NetTopologyMutation) ResetTopologyName() {
	m.topology_name = nil
}

// SetTopologyDescription sets the "topology_description" field.
func (m *NetTopologyMutation) SetTopologyDescription(s string) {
	m.topology_description = &s
}

// TopologyDescription returns the value of the "topology_description" field in the mutation.
func (m *NetTopologyMutation) TopologyDescription() (r string, exists bool) {
	v := m.topology_description
	if v == nil {
		return
	}
	return *v, true
}

// OldTopologyDescription returns the old "topology_description" field's value of the NetTopology entity.
// If the NetTopology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetTopologyMutation) OldTopologyDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTopologyDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTopologyDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopologyDescription: %w", err)
	}
	return oldValue.TopologyDescription, nil
}

// ResetTopologyDescription resets all changes to the "topology_description" field.
func (m *NetTopologyMutation) ResetTopologyDescription() {
	m.topology_description = nil
}

// AddTopologyIDs adds the "topology" edge to the NetTopologyDeviceMap entity by ids.
func (m *NetTopologyMutation) AddTopologyIDs(ids ...int) {
	if m.topology == nil {
		m.topology = make(map[int]struct{})
	}
	for i := range ids {
		m.topology[ids[i]] = struct{}{}
	}
}

// ClearTopology clears the "topology" edge to the NetTopologyDeviceMap entity.
func (m *NetTopologyMutation) ClearTopology() {
	m.clearedtopology = true
}

// TopologyCleared reports if the "topology" edge to the NetTopologyDeviceMap entity was cleared.
func (m *NetTopologyMutation) TopologyCleared() bool {
	return m.clearedtopology
}

// RemoveTopologyIDs removes the "topology" edge to the NetTopologyDeviceMap entity by IDs.
func (m *NetTopologyMutation) RemoveTopologyIDs(ids ...int) {
	if m.removedtopology == nil {
		m.removedtopology = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtopology[ids[i]] = struct{}{}
	}
}

// RemovedTopology returns the removed IDs of the "topology" edge to the NetTopologyDeviceMap entity.
func (m *NetTopologyMutation) RemovedTopologyIDs() (ids []int) {
	for id := range m.removedtopology {
		ids = append(ids, id)
	}
	return
}

// TopologyIDs returns the "topology" edge IDs in the mutation.
func (m *NetTopologyMutation) TopologyIDs() (ids []int) {
	for id := range m.topology {
		ids = append(ids, id)
	}
	return
}

// ResetTopology resets all changes to the "topology" edge.
func (m *NetTopologyMutation) ResetTopology() {
	m.topology = nil
	m.clearedtopology = false
	m.removedtopology = nil
}

// Op returns the operation name.
func (m *NetTopologyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetTopology).
func (m *NetTopologyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetTopologyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.topology_name != nil {
		fields = append(fields, nettopology.FieldTopologyName)
	}
	if m.topology_description != nil {
		fields = append(fields, nettopology.FieldTopologyDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetTopologyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nettopology.FieldTopologyName:
		return m.TopologyName()
	case nettopology.FieldTopologyDescription:
		return m.TopologyDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetTopologyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nettopology.FieldTopologyName:
		return m.OldTopologyName(ctx)
	case nettopology.FieldTopologyDescription:
		return m.OldTopologyDescription(ctx)
	}
	return nil, fmt.Errorf("unknown NetTopology field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetTopologyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nettopology.FieldTopologyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopologyName(v)
		return nil
	case nettopology.FieldTopologyDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopologyDescription(v)
		return nil
	}
	return fmt.Errorf("unknown NetTopology field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetTopologyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetTopologyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetTopologyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetTopology numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetTopologyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetTopologyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetTopologyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetTopology nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetTopologyMutation) ResetField(name string) error {
	switch name {
	case nettopology.FieldTopologyName:
		m.ResetTopologyName()
		return nil
	case nettopology.FieldTopologyDescription:
		m.ResetTopologyDescription()
		return nil
	}
	return fmt.Errorf("unknown NetTopology field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetTopologyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.topology != nil {
		edges = append(edges, nettopology.EdgeTopology)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetTopologyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nettopology.EdgeTopology:
		ids := make([]ent.Value, 0, len(m.topology))
		for id := range m.topology {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetTopologyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtopology != nil {
		edges = append(edges, nettopology.EdgeTopology)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetTopologyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nettopology.EdgeTopology:
		ids := make([]ent.Value, 0, len(m.removedtopology))
		for id := range m.removedtopology {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetTopologyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtopology {
		edges = append(edges, nettopology.EdgeTopology)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetTopologyMutation) EdgeCleared(name string) bool {
	switch name {
	case nettopology.EdgeTopology:
		return m.clearedtopology
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetTopologyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown NetTopology unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetTopologyMutation) ResetEdge(name string) error {
	switch name {
	case nettopology.EdgeTopology:
		m.ResetTopology()
		return nil
	}
	return fmt.Errorf("unknown NetTopology edge %s", name)
}

// NetTopologyDeviceMapMutation represents an operation that mutates the NetTopologyDeviceMap nodes in the graph.
type NetTopologyDeviceMapMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	position_x         *int
	addposition_x      *int
	position_y         *int
	addposition_y      *int
	clearedFields      map[string]struct{}
	on_topology        *int
	clearedon_topology bool
	device             *int
	cleareddevice      bool
	edge               map[int]struct{}
	removededge        map[int]struct{}
	clearededge        bool
	done               bool
	oldValue           func(context.Context) (*NetTopologyDeviceMap, error)
	predicates         []predicate.NetTopologyDeviceMap
}

var _ ent.Mutation = (*NetTopologyDeviceMapMutation)(nil)

// nettopologydevicemapOption allows management of the mutation configuration using functional options.
type nettopologydevicemapOption func(*NetTopologyDeviceMapMutation)

// newNetTopologyDeviceMapMutation creates new mutation for the NetTopologyDeviceMap entity.
func newNetTopologyDeviceMapMutation(c config, op Op, opts ...nettopologydevicemapOption) *NetTopologyDeviceMapMutation {
	m := &NetTopologyDeviceMapMutation{
		config:        c,
		op:            op,
		typ:           TypeNetTopologyDeviceMap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetTopologyDeviceMapID sets the ID field of the mutation.
func withNetTopologyDeviceMapID(id int) nettopologydevicemapOption {
	return func(m *NetTopologyDeviceMapMutation) {
		var (
			err   error
			once  sync.Once
			value *NetTopologyDeviceMap
		)
		m.oldValue = func(ctx context.Context) (*NetTopologyDeviceMap, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetTopologyDeviceMap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetTopologyDeviceMap sets the old NetTopologyDeviceMap of the mutation.
func withNetTopologyDeviceMap(node *NetTopologyDeviceMap) nettopologydevicemapOption {
	return func(m *NetTopologyDeviceMapMutation) {
		m.oldValue = func(context.Context) (*NetTopologyDeviceMap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetTopologyDeviceMapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetTopologyDeviceMapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NetTopologyDeviceMapMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPositionX sets the "position_x" field.
func (m *NetTopologyDeviceMapMutation) SetPositionX(i int) {
	m.position_x = &i
	m.addposition_x = nil
}

// PositionX returns the value of the "position_x" field in the mutation.
func (m *NetTopologyDeviceMapMutation) PositionX() (r int, exists bool) {
	v := m.position_x
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionX returns the old "position_x" field's value of the NetTopologyDeviceMap entity.
// If the NetTopologyDeviceMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetTopologyDeviceMapMutation) OldPositionX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionX: %w", err)
	}
	return oldValue.PositionX, nil
}

// AddPositionX adds i to the "position_x" field.
func (m *NetTopologyDeviceMapMutation) AddPositionX(i int) {
	if m.addposition_x != nil {
		*m.addposition_x += i
	} else {
		m.addposition_x = &i
	}
}

// AddedPositionX returns the value that was added to the "position_x" field in this mutation.
func (m *NetTopologyDeviceMapMutation) AddedPositionX() (r int, exists bool) {
	v := m.addposition_x
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionX resets all changes to the "position_x" field.
func (m *NetTopologyDeviceMapMutation) ResetPositionX() {
	m.position_x = nil
	m.addposition_x = nil
}

// SetPositionY sets the "position_y" field.
func (m *NetTopologyDeviceMapMutation) SetPositionY(i int) {
	m.position_y = &i
	m.addposition_y = nil
}

// PositionY returns the value of the "position_y" field in the mutation.
func (m *NetTopologyDeviceMapMutation) PositionY() (r int, exists bool) {
	v := m.position_y
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionY returns the old "position_y" field's value of the NetTopologyDeviceMap entity.
// If the NetTopologyDeviceMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetTopologyDeviceMapMutation) OldPositionY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionY: %w", err)
	}
	return oldValue.PositionY, nil
}

// AddPositionY adds i to the "position_y" field.
func (m *NetTopologyDeviceMapMutation) AddPositionY(i int) {
	if m.addposition_y != nil {
		*m.addposition_y += i
	} else {
		m.addposition_y = &i
	}
}

// AddedPositionY returns the value that was added to the "position_y" field in this mutation.
func (m *NetTopologyDeviceMapMutation) AddedPositionY() (r int, exists bool) {
	v := m.addposition_y
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionY resets all changes to the "position_y" field.
func (m *NetTopologyDeviceMapMutation) ResetPositionY() {
	m.position_y = nil
	m.addposition_y = nil
}

// SetOnTopologyID sets the "on_topology" edge to the NetTopology entity by id.
func (m *NetTopologyDeviceMapMutation) SetOnTopologyID(id int) {
	m.on_topology = &id
}

// ClearOnTopology clears the "on_topology" edge to the NetTopology entity.
func (m *NetTopologyDeviceMapMutation) ClearOnTopology() {
	m.clearedon_topology = true
}

// OnTopologyCleared reports if the "on_topology" edge to the NetTopology entity was cleared.
func (m *NetTopologyDeviceMapMutation) OnTopologyCleared() bool {
	return m.clearedon_topology
}

// OnTopologyID returns the "on_topology" edge ID in the mutation.
func (m *NetTopologyDeviceMapMutation) OnTopologyID() (id int, exists bool) {
	if m.on_topology != nil {
		return *m.on_topology, true
	}
	return
}

// OnTopologyIDs returns the "on_topology" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OnTopologyID instead. It exists only for internal usage by the builders.
func (m *NetTopologyDeviceMapMutation) OnTopologyIDs() (ids []int) {
	if id := m.on_topology; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOnTopology resets all changes to the "on_topology" edge.
func (m *NetTopologyDeviceMapMutation) ResetOnTopology() {
	m.on_topology = nil
	m.clearedon_topology = false
}

// SetDeviceID sets the "device" edge to the Device entity by id.
func (m *NetTopologyDeviceMapMutation) SetDeviceID(id int) {
	m.device = &id
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *NetTopologyDeviceMapMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *NetTopologyDeviceMapMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the "device" edge ID in the mutation.
func (m *NetTopologyDeviceMapMutation) DeviceID() (id int, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *NetTopologyDeviceMapMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *NetTopologyDeviceMapMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddEdgeIDs adds the "edge" edge to the NetTopologyDeviceMap entity by ids.
func (m *NetTopologyDeviceMapMutation) AddEdgeIDs(ids ...int) {
	if m.edge == nil {
		m.edge = make(map[int]struct{})
	}
	for i := range ids {
		m.edge[ids[i]] = struct{}{}
	}
}

// ClearEdgeEdge clears the "edge" edge to the NetTopologyDeviceMap entity.
func (m *NetTopologyDeviceMapMutation) ClearEdgeEdge() {
	m.clearededge = true
}

// EdgeEdgeCleared reports if the "edge" edge to the NetTopologyDeviceMap entity was cleared.
func (m *NetTopologyDeviceMapMutation) EdgeEdgeCleared() bool {
	return m.clearededge
}

// RemoveEdgeIDs removes the "edge" edge to the NetTopologyDeviceMap entity by IDs.
func (m *NetTopologyDeviceMapMutation) RemoveEdgeIDs(ids ...int) {
	if m.removededge == nil {
		m.removededge = make(map[int]struct{})
	}
	for i := range ids {
		m.removededge[ids[i]] = struct{}{}
	}
}

// RemovedEdge returns the removed IDs of the "edge" edge to the NetTopologyDeviceMap entity.
func (m *NetTopologyDeviceMapMutation) RemovedEdgeIDs() (ids []int) {
	for id := range m.removededge {
		ids = append(ids, id)
	}
	return
}

// EdgeIDs returns the "edge" edge IDs in the mutation.
func (m *NetTopologyDeviceMapMutation) EdgeIDs() (ids []int) {
	for id := range m.edge {
		ids = append(ids, id)
	}
	return
}

// ResetEdgeEdge resets all changes to the "edge" edge.
func (m *NetTopologyDeviceMapMutation) ResetEdgeEdge() {
	m.edge = nil
	m.clearededge = false
	m.removededge = nil
}

// Op returns the operation name.
func (m *NetTopologyDeviceMapMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NetTopologyDeviceMap).
func (m *NetTopologyDeviceMapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetTopologyDeviceMapMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.position_x != nil {
		fields = append(fields, nettopologydevicemap.FieldPositionX)
	}
	if m.position_y != nil {
		fields = append(fields, nettopologydevicemap.FieldPositionY)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetTopologyDeviceMapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		return m.PositionX()
	case nettopologydevicemap.FieldPositionY:
		return m.PositionY()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetTopologyDeviceMapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		return m.OldPositionX(ctx)
	case nettopologydevicemap.FieldPositionY:
		return m.OldPositionY(ctx)
	}
	return nil, fmt.Errorf("unknown NetTopologyDeviceMap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetTopologyDeviceMapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionX(v)
		return nil
	case nettopologydevicemap.FieldPositionY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionY(v)
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetTopologyDeviceMapMutation) AddedFields() []string {
	var fields []string
	if m.addposition_x != nil {
		fields = append(fields, nettopologydevicemap.FieldPositionX)
	}
	if m.addposition_y != nil {
		fields = append(fields, nettopologydevicemap.FieldPositionY)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetTopologyDeviceMapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		return m.AddedPositionX()
	case nettopologydevicemap.FieldPositionY:
		return m.AddedPositionY()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetTopologyDeviceMapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionX(v)
		return nil
	case nettopologydevicemap.FieldPositionY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionY(v)
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetTopologyDeviceMapMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetTopologyDeviceMapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetTopologyDeviceMapMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NetTopologyDeviceMap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetTopologyDeviceMapMutation) ResetField(name string) error {
	switch name {
	case nettopologydevicemap.FieldPositionX:
		m.ResetPositionX()
		return nil
	case nettopologydevicemap.FieldPositionY:
		m.ResetPositionY()
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetTopologyDeviceMapMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.on_topology != nil {
		edges = append(edges, nettopologydevicemap.EdgeOnTopology)
	}
	if m.device != nil {
		edges = append(edges, nettopologydevicemap.EdgeDevice)
	}
	if m.edge != nil {
		edges = append(edges, nettopologydevicemap.EdgeEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetTopologyDeviceMapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nettopologydevicemap.EdgeOnTopology:
		if id := m.on_topology; id != nil {
			return []ent.Value{*id}
		}
	case nettopologydevicemap.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case nettopologydevicemap.EdgeEdge:
		ids := make([]ent.Value, 0, len(m.edge))
		for id := range m.edge {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetTopologyDeviceMapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removededge != nil {
		edges = append(edges, nettopologydevicemap.EdgeEdge)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetTopologyDeviceMapMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nettopologydevicemap.EdgeEdge:
		ids := make([]ent.Value, 0, len(m.removededge))
		for id := range m.removededge {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetTopologyDeviceMapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedon_topology {
		edges = append(edges, nettopologydevicemap.EdgeOnTopology)
	}
	if m.cleareddevice {
		edges = append(edges, nettopologydevicemap.EdgeDevice)
	}
	if m.clearededge {
		edges = append(edges, nettopologydevicemap.EdgeEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetTopologyDeviceMapMutation) EdgeCleared(name string) bool {
	switch name {
	case nettopologydevicemap.EdgeOnTopology:
		return m.clearedon_topology
	case nettopologydevicemap.EdgeDevice:
		return m.cleareddevice
	case nettopologydevicemap.EdgeEdge:
		return m.clearededge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetTopologyDeviceMapMutation) ClearEdge(name string) error {
	switch name {
	case nettopologydevicemap.EdgeOnTopology:
		m.ClearOnTopology()
		return nil
	case nettopologydevicemap.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetTopologyDeviceMapMutation) ResetEdge(name string) error {
	switch name {
	case nettopologydevicemap.EdgeOnTopology:
		m.ResetOnTopology()
		return nil
	case nettopologydevicemap.EdgeDevice:
		m.ResetDevice()
		return nil
	case nettopologydevicemap.EdgeEdge:
		m.ResetEdgeEdge()
		return nil
	}
	return fmt.Errorf("unknown NetTopologyDeviceMap edge %s", name)
}

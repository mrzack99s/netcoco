// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/mrzack99s/netcoco/ent/device"
	"github.com/mrzack99s/netcoco/ent/ipstaticroutingtable"
	"github.com/mrzack99s/netcoco/ent/netinterface"
)

// IPStaticRoutingTable is the model entity for the IPStaticRoutingTable schema.
type IPStaticRoutingTable struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// NetworkAddress holds the value of the "network_address" field.
	NetworkAddress string `json:"network_address,omitempty"`
	// SubnetMask holds the value of the "subnet_mask" field.
	SubnetMask string `json:"subnet_mask,omitempty"`
	// NextHop holds the value of the "next_hop" field.
	NextHop string `json:"next_hop,omitempty"`
	// BrdInterface holds the value of the "brd_interface" field.
	BrdInterface bool `json:"brd_interface,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the IPStaticRoutingTableQuery when eager-loading is set.
	Edges                           IPStaticRoutingTableEdges `json:"edges"`
	device_ip_static_routing        *int
	net_interface_ip_static_routing *int
}

// IPStaticRoutingTableEdges holds the relations/edges for other nodes in the graph.
type IPStaticRoutingTableEdges struct {
	// OnDevice holds the value of the on_device edge.
	OnDevice *Device `json:"on_device,omitempty"`
	// OnInterface holds the value of the on_interface edge.
	OnInterface *NetInterface `json:"on_interface,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// OnDeviceOrErr returns the OnDevice value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e IPStaticRoutingTableEdges) OnDeviceOrErr() (*Device, error) {
	if e.loadedTypes[0] {
		if e.OnDevice == nil {
			// The edge on_device was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: device.Label}
		}
		return e.OnDevice, nil
	}
	return nil, &NotLoadedError{edge: "on_device"}
}

// OnInterfaceOrErr returns the OnInterface value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e IPStaticRoutingTableEdges) OnInterfaceOrErr() (*NetInterface, error) {
	if e.loadedTypes[1] {
		if e.OnInterface == nil {
			// The edge on_interface was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: netinterface.Label}
		}
		return e.OnInterface, nil
	}
	return nil, &NotLoadedError{edge: "on_interface"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*IPStaticRoutingTable) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case ipstaticroutingtable.FieldBrdInterface:
			values[i] = new(sql.NullBool)
		case ipstaticroutingtable.FieldID:
			values[i] = new(sql.NullInt64)
		case ipstaticroutingtable.FieldNetworkAddress, ipstaticroutingtable.FieldSubnetMask, ipstaticroutingtable.FieldNextHop:
			values[i] = new(sql.NullString)
		case ipstaticroutingtable.ForeignKeys[0]: // device_ip_static_routing
			values[i] = new(sql.NullInt64)
		case ipstaticroutingtable.ForeignKeys[1]: // net_interface_ip_static_routing
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type IPStaticRoutingTable", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the IPStaticRoutingTable fields.
func (isrt *IPStaticRoutingTable) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case ipstaticroutingtable.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			isrt.ID = int(value.Int64)
		case ipstaticroutingtable.FieldNetworkAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field network_address", values[i])
			} else if value.Valid {
				isrt.NetworkAddress = value.String
			}
		case ipstaticroutingtable.FieldSubnetMask:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field subnet_mask", values[i])
			} else if value.Valid {
				isrt.SubnetMask = value.String
			}
		case ipstaticroutingtable.FieldNextHop:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field next_hop", values[i])
			} else if value.Valid {
				isrt.NextHop = value.String
			}
		case ipstaticroutingtable.FieldBrdInterface:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field brd_interface", values[i])
			} else if value.Valid {
				isrt.BrdInterface = value.Bool
			}
		case ipstaticroutingtable.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field device_ip_static_routing", value)
			} else if value.Valid {
				isrt.device_ip_static_routing = new(int)
				*isrt.device_ip_static_routing = int(value.Int64)
			}
		case ipstaticroutingtable.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field net_interface_ip_static_routing", value)
			} else if value.Valid {
				isrt.net_interface_ip_static_routing = new(int)
				*isrt.net_interface_ip_static_routing = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryOnDevice queries the "on_device" edge of the IPStaticRoutingTable entity.
func (isrt *IPStaticRoutingTable) QueryOnDevice() *DeviceQuery {
	return (&IPStaticRoutingTableClient{config: isrt.config}).QueryOnDevice(isrt)
}

// QueryOnInterface queries the "on_interface" edge of the IPStaticRoutingTable entity.
func (isrt *IPStaticRoutingTable) QueryOnInterface() *NetInterfaceQuery {
	return (&IPStaticRoutingTableClient{config: isrt.config}).QueryOnInterface(isrt)
}

// Update returns a builder for updating this IPStaticRoutingTable.
// Note that you need to call IPStaticRoutingTable.Unwrap() before calling this method if this IPStaticRoutingTable
// was returned from a transaction, and the transaction was committed or rolled back.
func (isrt *IPStaticRoutingTable) Update() *IPStaticRoutingTableUpdateOne {
	return (&IPStaticRoutingTableClient{config: isrt.config}).UpdateOne(isrt)
}

// Unwrap unwraps the IPStaticRoutingTable entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (isrt *IPStaticRoutingTable) Unwrap() *IPStaticRoutingTable {
	tx, ok := isrt.config.driver.(*txDriver)
	if !ok {
		panic("ent: IPStaticRoutingTable is not a transactional entity")
	}
	isrt.config.driver = tx.drv
	return isrt
}

// String implements the fmt.Stringer.
func (isrt *IPStaticRoutingTable) String() string {
	var builder strings.Builder
	builder.WriteString("IPStaticRoutingTable(")
	builder.WriteString(fmt.Sprintf("id=%v", isrt.ID))
	builder.WriteString(", network_address=")
	builder.WriteString(isrt.NetworkAddress)
	builder.WriteString(", subnet_mask=")
	builder.WriteString(isrt.SubnetMask)
	builder.WriteString(", next_hop=")
	builder.WriteString(isrt.NextHop)
	builder.WriteString(", brd_interface=")
	builder.WriteString(fmt.Sprintf("%v", isrt.BrdInterface))
	builder.WriteByte(')')
	return builder.String()
}

// IPStaticRoutingTables is a parsable slice of IPStaticRoutingTable.
type IPStaticRoutingTables []*IPStaticRoutingTable

func (isrt IPStaticRoutingTables) config(cfg config) {
	for _i := range isrt {
		isrt[_i].config = cfg
	}
}
